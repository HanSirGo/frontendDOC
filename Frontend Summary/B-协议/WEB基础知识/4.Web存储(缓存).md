#### 1. **Cookie**

var cookie = {}; 

/* * @描述 设置cookie * @函数 cookie.set * @参数 */ 

cookie.set = function(key,value,day){ 

day = day || 1; 

var date = new Date(); 

var expires; 

date.setTime(date.getTime()+day*24*60*60*1000); expires = 'expires='+date.toGMTString(); 

document.cookie=key+'='+value+';'+expires+';path=/'; 

} 

 

/* * @描述 获取cookie * @函数 cookie.get * @参数 key */ 

cookie.get = function(key){ 

var cookie = document.cookie; 

var arr = cookie.split(';'); 

var obj = {}; 

var element; 

for(var i=0;i<arr.length;i++){

Element = arr[i].split(“=”);

Obj[element[0]] = element[1];

}

return obj[key] ? obj[key] : obj[' '+key];

}

 

/* * @描述 删除cookie * @函数 cookie.remove * @参数 key 键 */ 

cookie.remove = function(key){ cookie.set(key,cookie.get(key),-1); }

 

#### 2. **Localstorage （****HTML5****）**

setItem(): "增（改）"，将数据以键值对的形式存到 LocalStorage 中

getItem(): "查"，从 LocalStorage 获得对应键值的数据

removeItem(): "删"，删除 LocalStorage 中给定键的数据条目

clear(): 清空 LocalStorage

key(): 传递一个数字 n，获取第 n 个键的数据

#### 3. **Sessionstorage**

sessionStorage.setItem('testKey','这是一个测试的value值'); // 存入一个值

|      | sessionStorage['testKey'] = '这是一个测试的value值'; |
| ---- | ---------------------------------------------------- |
|      |                                                      |

sessionStorage.getItem('testKey'); // => 返回testKey对应的值

|      | sessionStorage['testKey']; // => 这是一个测试的value值 |
| ---- | ------------------------------------------------------ |
|      |                                                        |

**同localStorage的方法相同**

#### 4. **Cookie、localStorage、sessionStorage的区别**

一、存储的时间有效期不同

1、cookie的有效期是可以设置的，默认的情况下是关闭浏览器后失效

2、sessionStorage的有效期是仅保持在当前页面，关闭当前会话页或者浏览器后就会失效

3、localStorage的有效期是在不进行手动删除的情况下是一直有效的

二、存储的大小不同

1、cookie的存储是4kb左右，存储量较小，一般页面最多存储20条左右信息

2、localStorage和sessionStorage的存储容量是5Mb(官方介绍，可能和浏览器有部分差异性)

三、与服务端的通信

1、cookie会参与到与服务端的通信中，一般会携带在http请求的头部中，例如一些关键密匙验证等。

2、localStorage和sessionStorage是单纯的前端存储，不参与与服务端的通信

#### 5. **离线存储（HTML5）**

离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。

##### (1) **浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢****？**

l 在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。

l 离线的情况下，浏览器会直接使用离线存储的资源。

##### (2) **原理**

原理：[HTML5](https://so.csdn.net/so/search?q=HTML5&spm=1001.2101.3001.7020)的离线存储是基于一个新建的 .appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示

##### (3) **使用方法**

（1）创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：

<html lang="en" manifest="index.manifest">

（2）在 cache.manifest 文件中编写需要离线存储的资源：

CACHE MANIFEST

​    \#v0.11

​    CACHE:

​    js/app.js

​    css/style.css

​    NETWORK:

​    resourse/logo.png

​    FALLBACK:

​    / /offline.html

**l** **CACHE**: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。

**l** **NETWORK**: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。

**l** **FALLBACK**: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。

 

（3）在离线状态时，操作 window.applicationCache 进行离线缓存的操作。

如何更新缓存：

​    （1）更新 manifest 文件

​    （2）通过 javascript 操作

（3）清除浏览器缓存

##### (4) **注意事项**

（1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。

（2）若manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。

（3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。

（4）FALLBACK 中的资源必须和 manifest 文件同源。

（5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。

（6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。

（7）当 manifest 文件发生改变时，资源请求本身也会触发更新