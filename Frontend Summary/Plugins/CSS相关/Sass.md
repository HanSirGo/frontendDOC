# sass用法

## 准备工作

1、全局安装sass

```
npm install -g sass
```

2、在本地文件夹中新建index.scss、index.html

3、初始化package.json。并且安装sass

```
npm init -y
```

4、在index.scss中写入scss语法样式。执行编译语句

```
sass index.scss output.css
```

5、在output.css可以看见编译过来的scss样式。

6、在index.html中引入output.css，即可看见样式效果

## 嵌套

```scss
#main {
    width: 97%;
    .content{
        background-color: orange;
        .title{
            font-weight: 900;
            i{
                font-size: 30px;
            }
        }
    }
}
```

被编译为：

```scss
#main {
  width: 97%;
}
#main .content {
  background-color: orange;
}
#main .content .title {
  font-weight: 900;
}
#main .content .title i {
  font-size: 30px;
}
```

### 1.1、属性嵌套

CSS在“名称空间”中有很多属性。例如font-family，font-size和font-weight都在font命名空间。在CSS中，如果你想在同一个命名空间中设置一堆属性，你必须每次输入它。Sass为此提供了一个快捷方式：只需写一次名称空间，然后在其中嵌套每个子属性。例如：

```scss
.funky {
  font: {
    family: fantasy;
    size: 30em;
    weight: bold;
  }
  background: {
      color: red;
      size: 100% 100%;
      position: center;
  }
}
```

被编译为：

```scss
.funky {
  font-family: fantasy;
  font-size: 30em;
  font-weight: bold;
  background-color: red;
  background-size: 100% 100%;
  background-position: center;
}
```

## 引用父选择器：&

### 1、普通引用父选择器

有时候，使用嵌套规则的父选择器的方式与默认方式不同。例如：hover。

```scss
#main {
  color: black;
  a {
    font-weight: bold;
    &:hover { color: red; }
  }
}
```

被编译为：

```scss
#main {
  color: black;
}
#main a {
  font-weight: bold;
}
#main a:hover {
  color: red;
}
```

### 2、复合选择器

```scss
#main {
    color: black;
    &-content { 
        border: 1px solid; 
        &-title{
            font-weight: 800;
            &-icon{
                font-size: 40px;
            }
        }
    }
}
```

被编译为：

```scss
#main {
  color: black;
}
#main-content {
  border: 1px solid;
}
#main-content-title {
  font-weight: 800;
}
#main-content-title-icon {
  font-size: 40px;
}
```

## 注释：/* */和//

Sass支持标准的多行CSS注释/* */，以及单行注释//。多行注释尽可能保留在CSS输出中，而单行注释则被删除。例如：

```scss
/* This comment is
 * several lines long.
 * since it uses the CSS comment syntax,
 * it will appear in the CSS output. */

// font serise
// font serise
body{ color: red }
```

被编译为：

```scss
/* This comment is
 * several lines long.
 * since it uses the CSS comment syntax,
 * it will appear in the CSS output. */

// font serise
// font serise
body{ color: red }
```

### 1、多行注释插值

```scss
$version: "1.2.3";
/* This CSS is generated by My Snazzy Framework version #{$version}. */
body{
    padding: 0;
}
```

被编译为：

```scss
/* This CSS is generated by My Snazzy Framework version 1.2.3. */
body {
  padding: 0;
}
```

## 插值：

您可以使用#{}插值语法在选择器和属性名称中使用SassScript变量：

```scss
$name: foo;
$attr: border;
p.#{$name} {
  #{$attr}-color: blue;
}
```

被编译为：

```scss
p.foo {
  border-color: blue;
}
```

也可以使用#{}将SassScript放入属性值中。在大多数情况下，这并不比使用变量更好，但使用#{}意味着它附近的任何操作都将被视为纯CSS。例如：

```scss
p {
    $font-size: 12px;
    $line-height: 30px;
    font: #{$font-size}/#{$line-height};
  }
```

被编译为：

```scss
p {
  font: 12px/30px;
}
```

## @import、@media、@extend

### 1、@import

Sass扩展了CSS @import规则，允许它导入SCSS和Sass文件。所有导入的SCSS和Sass文件将合并成一个CSS输出文件。另外，在主文件中可以使用在导入文件中定义的任何变量或mixin。

```scss
@import "foo";
```

或者同时导入多个

```scss
@import "rounded-corners", "text-shadow";
```

### 2、嵌套@import

如果demo.scss包含

```scss
.demo{
    color: red;
}
```

然后

```scss
#app{
    font-weight: 800;
    @import "./demo.scss";
}
```

### 3、@media

Sass中的指令就像它们在纯CSS中一样，具有一个额外的功能：它们可以嵌套在CSS规则中。如果@media指令出现在CSS规则中，它将冒泡到样式表的顶层，将所有选择器放在规则内。这样可以轻松添加媒体特定的样式，而无需重复选择器或中断样式表的流程。

```scss
.sidebar {
  width: 300px;
  @media screen and (orientation: landscape) {
    width: 500px;
  }
}
```

被编译为：

```scss
.sidebar {
  width: 300px;
}
@media screen and (orientation: landscape) {
  .sidebar {
    width: 500px;
  }
}
```

### 4、@extend

这个指令是非常有用的。

当一个类应该具有另一个类的所有样式以及它自己的特定样式时，经常会有设计页面的情况。处理这种情况的最常见方式是在HTML中使用更一般的类和更具体的类。例如，假设我们设计了一个正常的错误，并且还有一个严重的错误。我们可能会这样写我们的标记：

```html
<div class="error seriousError">
  Oh no! You've been hacked!
</div>
```

我们的风格如下：

```scss
.error {
  border: 1px #f00;
  background-color: #fdd;
}
.seriousError {
  border-width: 3px;
}
```

不幸的是，这意味着我们必须永远记住使用.seriousErro时需要参考.error的样式。这是一个维护负担，会导致棘手的错误，并且可能会将非语义风格问题带入标记。

@extend通过告诉Sass一个选择器应该继承另一个选择器的样式，该指令避免了这些问题。例如：

```scss
.error {
  border: 1px #f00;
  background-color: #fdd;
}
.seriousError {
  @extend .error;
  border-width: 3px;
}
```

被编译为：

```scss
.error, .seriousError {
  border: 1px #f00;
  background-color: #fdd;
}

.seriousError {
  border-width: 3px;
}
```

**多重扩展**

一个选择器可以扩展多个选择器。这意味着它继承了所有扩展选择器的样式。例如：

```scss
.error {
  border: 1px #f00;
  background-color: #fdd;
}
.attention {
  font-size: 3em;
  background-color: #ff0;
}
.seriousError {
  @extend .error;
  @extend .attention;
  border-width: 3px;
}
```

被编译为：

```scss
.error, .seriousError {
  border: 1px #f00;
  background-color: #fdd;
}

.attention, .seriousError {
  font-size: 3em;
  background-color: #ff0;
}

.seriousError {
  border-width: 3px;
}
```



## 控制指令和表达

SassScript支持基本的控制指令和表达式，仅用于在某些情况下包含样式，或者在变体中多次包含相同样式。

### 1.if()函数

可以将if函数看作为3个参数。if(condition, trueValue, otherValue)。trueValue、otherValue可以是任何 Sass 值，例如颜色、字体大小、间距等。

以下是一个简单的示例：

```scss
$font-size: 16px;  
$breakpoint: 768px;  
  
.title {  
  font-size: if($breakpoint >= 768px, 24px, $font-size);
    i{
        font-size: if($breakpoint > 768px, 24px, $font-size);
    }
}
```

被编译为：

```scss
.title {
  font-size: 24px;
}
.title i {
  font-size: 16px;
}
```

### 2.@if指令

@if声明可以由几个@else if语句，一个@else声明。如果@if陈述失败，@else if则按顺序尝试陈述，直到成功或@else达到陈述。例如：

```scss
$type: monster;
p {
  @if $type == ocean {
    color: blue;
  } @else if $type == matador {
    color: red;
  } @else if $type == monster {
    color: green;
  } @else {
    color: black;
  }
}
```

被编译为：

```scss
p {  color: green;}
```

### 3.@for指令

@for指令重复输出一组样式。对于每次重复，计数器变量用于调整输出。该指令有两种形式:

**@for $var from [start] through [end]**

**@for $var from [start] to [end]**

$var可以是任何变量名称。[start]并且[end]是应该返回整数的SassScript表达式。

**「1、请注意关键字through和区别to」**

```scss
@for $i from 1 to 3 {
    .item-#{$i} {
        width: 2px * $i
    }
}
// 编译后
.item-1 {
  width: 2px;
}

.item-2 {
  width: 4px;
}
```

```scss
@for $i from 1 through 3 {
    .row-#{$i} {
        height: 2px * $i
    }
}
// 编译后
.row-1 {
  height: 2px;
}

.row-2 {
  height: 4px;
}

.row-3 {
  height: 6px;
}
```

得到：具有以下形式from ... through，所述范围包括的值[start]和[end]，但形式from ... to运行至但不包括的值[end]

**「2、递减|递增」**

```scss
@for $i from 1 through 2 {
    .item-#{$i} {
        width: 2px * $i
    }
}

@for $i from 2 through 1 {
    .item-#{$i} {
        width: 2px * $i
    }
}
```

编译后

```scss
.item-1 {
  width: 2px;
}

.item-2 {
  width: 4px;
}

.item-2 {
  width: 4px;
}

.item-1 {
  width: 2px;
}
```

所以：**start > end ? 递减 : 递增**

### 4.@each指令

@each指令的格式是$var in list

```scss
@each $animal in puma, sea-slug, egret, salamander {
    .#{$animal}-icon {
        background-image: url('/images/#{$animal}.png');
    }
}
```

编译为：

```scss
.puma-icon {
  background-image: url("/images/puma.png");
}

.sea-slug-icon {
  background-image: url("/images/sea-slug.png");
}

.egret-icon {
  background-image: url("/images/egret.png");
}

.salamander-icon {
  background-image: url("/images/salamander.png");
}
```

**@each指令也可以使用多个变量**

如in @each var2, ... in list。如果list是列表列表，则将子列表的每个元素分配给相应的变量。例如：

```scss
@each $animal, $color, $cursor in (puma, black, default),
                                  (sea-slug, blue, pointer),
                                  (egret, white, move) {
  .#{$animal}-icon {
    background-image: url('/images/#{$animal}.png');
    border: 2px solid $color;
    cursor: $cursor;
  }
}
```

被编译为：

```scss
.puma-icon {
  background-image: url('/images/puma.png');
  border: 2px solid black;
  cursor: default; }
.sea-slug-icon {
  background-image: url('/images/sea-slug.png');
  border: 2px solid blue;
  cursor: pointer; }
.egret-icon {
  background-image: url('/images/egret.png');
  border: 2px solid white;
  cursor: move; }
```

### 5.@while指令

@while指令采用SassScript表达式并重复输出嵌套样式，直到语句求值为止false。这可以用来实现比@for语句更复杂的循环，尽管这很少是必需的。例如：

```scss
$i: 6;
@while $i > 0 {
  .item-#{$i} { width: 2em * $i; }
  $i: $i - 2;
}
```

被编译为：

```scss
.item-6 {
  width: 12em;
}

.item-4 {
  width: 8em;
}

.item-2 {
  width: 4em;
}
```

## 混合指令#mixins

Mixins允许您定义可以在整个样式表中重用的样式，而无需使用类似的非语义类.float-left。

### 1.指令定义

Mixins由@mixin指令定义。它后面跟着mixin的名称和可选的参数，以及一个包含mixin内容的块。例如，large-textmixin定义如下：

```scss
@mixin large-text {
    font: {
        family: Arial;
        size: 20px;
        weight: bold;
    }
    color: #ff0000;
}
```

### 2.引用mixins

Mixins包含在@include指令文档中。这需要一个mixin的名称和可选的参数传递给它，并将该mixin定义的样式包含到当前规则中。例如：

```scss
@mixin large-text {
    font: {
        family: Arial;
        size: 20px;
        weight: bold;
    }
    color: #ff0000;
}

.page-title {
    @include large-text;
    padding: 4px;
    margin-top: 10px;
}
```

被编译为：

```scss
.page-title {
  font-family: Arial;
  font-size: 20px;
  font-weight: bold;
  color: #ff0000;
  padding: 4px;
  margin-top: 10px;
}
```

只要不直接定义任何属性或使用任何父引用，Mixin也可以包含在任何规则之外（即，位于文档的根目录）。例如：

```scss
@mixin silly-links {
  a {
    color: blue;
    background-color: red;
  }
}

@include silly-links;
```

被编译为：

```scss
a {
  color: blue;
  background-color: red;
}
```

### 3.mixins参数

Mixin可以将SassScript值作为参数，当mixin被包含并在mixin中作为变量提供时，会给出这些参数。

```scss
@mixin sexy-border($color, $width) {
  border: {
    color: $color;
    width: $width;
    style: dashed;
  }
}

p { @include sexy-border(blue, 1in); }
```

被编译为：

```scss
p {
  border-color: blue;
  border-width: 1in;
  border-style: dashed;
}
```

同理，还支持参数默认值

```scss
@mixin sexy-border($color, $width: 1in) {
    border: {
        color: $color;
        width: $width;
        style: dashed;
    }
}

p {
    @include sexy-border(blue);
}

h1 {
    @include sexy-border(blue, 2in);
}
```

被编译为：

```scss
p {
  border-color: blue;
  border-width: 1in;
  border-style: dashed;
}

h1 {
  border-color: blue;
  border-width: 2in;
  border-style: dashed;
}
```

### 4.将内容块传递给Mixin

除了上面传递参数给mixin，还可以传整个内容块

```scss
@mixin apply-to-ie6-only {
  * html {
    @content;
  }
}
@include apply-to-ie6-only {
  #logo {
    background-image: url(/logo.gif);
  }
}
```

产生：

```scss
* html #logo {
  background-image: url(/logo.gif);
}
```

### 5.变量参数...

有时候mixin或者函数需要一些未知数的参数是有意义的。例如，用于创建框阴影的混合可能会将任意数量的阴影作为参数。对于这些情况，Sass支持“可变参数”，这些参数是混合函数或函数声明结尾的参数，它们将所有剩余的参数作为列表打包。这些论点看起来就像正常的论点，但后面跟着...。例如：

```scss
@mixin box-shadow($shadows...) {
  -moz-box-shadow: $shadows;
  -webkit-box-shadow: $shadows;
  box-shadow: $shadows;
}

.shadows {
  @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);
}
```

被编译为：

```scss
.shadows {
  -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;
  -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;
  box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;
}
```

## 函数指令

可以在sass中定义自己的函数，并在任何值或脚本环境中使用它们。例如：

```scss
$grid-width: 40px;
$gutter-width: 10px;

@function grid-width($n) {
  @return $n * $grid-width + ($n - 1) * $gutter-width;
}

#sidebar { width: grid-width(5); }
```

变为:

```scss
#sidebar {
  width: 240px;
}
```

正如你所看到的，函数可以访问任何全局定义的变量以及像mixin一样接受参数。一个函数可能包含多个语句，并且您必须调用@return以设置该函数的返回值。

与mixin一样，您可以使用关键字参数调用Sass定义的函数。在上面的例子中，我们可以像这样调用函数：

```scss
#sidebar { width: grid-width($n: 5); }
```

建议您为函数加上前缀以避免命名冲突，并使样式表的读者知道它们不属于Sass或CSS。例如，如果您为ACME Corp工作，则可能已经命名了-acme-grid-width上的述功能。

用户定义的函数也像mixin一样支持可变参数。