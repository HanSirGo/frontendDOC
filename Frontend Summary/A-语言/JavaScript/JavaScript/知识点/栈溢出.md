# 无限递归一定会溢栈吗

### **一、问题**

面试题问题:

在浏览器控制台中运行foo函数，是否会导致堆栈溢出错误？

```js
function foo(){
  setTimeout(foo, 0); // 是否存在堆栈溢出错误
}
```

要解决这个问题，我们先要知道，什么情况会导致栈溢出。

## **二、栈溢出**

当JS引擎启动之后，它就会开辟一块固定大小的内存空间，每个浏览器的大小不一样，但是都是固定的，这个空间里面放什么，会放执行上下文，只要一调用函数，它就会放入一块执行上下文进去，不断调用就会不断放入执行上下文，等到函数调用之后，它就会出栈。

![1714801403890](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1714801403890.png)

那什么叫栈溢出，就是这个内存空间放不下了，放得太多了，这种情况一般会发生在无限递归的时候，或者是由于多次函数调用形成的调用链导致的。每次函数调用都会占用一定的栈空间，如果调用次数过多，栈空间会被耗尽，从而导致栈溢出错误。

就比如下面这个：

```js
function foo(){
  foo()
}
foo()
```

![1714801425158](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1714801425158.png)

为什么会这样，因为上面的foo函数，开始执行，然后还没有等它执行完，又去执行了foo函数，因为要出栈的话，是需要等函数执行完，才会出栈，现在它一直都不出栈，一直无限调用，无限入栈，那就肯定会出问题了。

### **三、setTimeOut递归1**

那既然还没有等foo函数执行完，才去执行foo，那我们就弄一个定时器去试一下。

```js
function foo(){
    setTimeout(foo, 0); // 是否存在堆栈溢出错误
}
foo()
```

这种情况，会导致栈溢出吗？不会的，等多久都不会。为什么这个情况不会有，就我上面说的一样，这里涉及到异步了。

当执行foo函数以后，它会去通知计时线程，去计时foo函数调用，等计时完成以后去调用那个foo，一旦发出了通知，这个函数本身它就结束了。于是它就出栈了，过了一会，刚刚那个计时线程发现刚刚那个计时到了，到达了之后，它会进入事件队列，这里就涉及事件循环了，这个时候，它会再来运行这个foo函数，然后又入栈，然后又和刚刚一样的操作进行，因为是异步，主线程是不会等待的，然后执行上下文就出栈了，如此不断循环。

所以上面题目，不会溢出堆栈。

## **四、setTimeOut递归2**

那如果是这样呢

```js
function foo(){
+   setTimeout(foo(), 0); // 是否存在堆栈溢出错误
}
foo()
```

这个时候可能有的会懵，其实它又回到了刚开始的那种情况，

一开始调用foo函数入栈，入栈过程中，它需要先调用foo去确定它的回调是什么，这是一个同步代码，于是又入栈了，然后又去调用foo，如此不断循环，它都还来不及去计时来确定这个foo函数的返回结果这一步，它就导致栈溢出啦。

这里setTimeout(foo(), 0): 这种写法实际上会立即调用函数 foo()，并将它的返回值传递给 setTimeout 函数。由于 foo() 在 setTimeout 内部被调用，这会导致 foo() 不断地在自己执行完毕后再次调用自己，从而导致无限递归。由于递归没有终止条件，这最终会导致堆栈溢出错误。

