## JavaScript中内存泄漏

> 在 JavaScript 中，内存泄漏是指由于代码中的错误或疏忽造成未使用的内存无法被垃圾回收机制正确释放的情况。
>
> 内存泄漏会导致程序占用的内存不断增加，最终可能导致系统性能下降甚至崩溃

#### 在JavaScript中，内存泄漏通常发生在以下情况

```js
# 不正确的使用全局变量：
不正确的使用全局变量可能会导致内存泄漏。

例如，如果你不小心将一个大的对象赋值给一个全局变量，那么即使你的代码不再需要这个对象，它仍然会被垃圾回收器保留，因为它可以通过全局变量访问。

let bigObject = new Array(1000000).fill('data');
window.bigObject = bigObject;  // 内存泄漏，因为bigObject通过全局变量window访问
```

```js
# 不正确使用闭包：
虽然闭包是JavaScript的一个重要特性，但如果不正确使用，它们可能会导致内存泄漏。

如果闭包引用了外部函数的变量，并且该变量的大小很大（例如，大数组或大对象），那么只要闭包还在被使用，该变量就不会被垃圾回收。

function outerFunction() {
    let bigObject = new Array(1000000).fill('data');
    function innerFunction() {
        console.log(bigObject);  // 内存泄漏，因为innerFunction引用了外部函数outerFunction的变量bigObject
    }
    innerFunction();
}
outerFunction();
```

```js
# 引用了一个外部变量定时器：
如果你在代码中设置了一个定时器，并且在其回调函数中引用了一个外部变量，那么只要定时器还在运行，该外部变量就不会被垃圾回收。

let bigObject = new Array(1000000).fill('data');
setInterval(() => { console.log(bigObject); }, 1000);  // 内存泄漏，因为定时器每隔1秒就访问一次外部变量bigObject
# 未清理的定时器：
function startTimer() {
  setInterval(function() {
    // 执行定时任务
  }, 1000);
}
startTimer();
在上述代码中，定时器被创建后，却没有被清除。这意味着每秒钟都会创建一个新的定时器，导致内存占用不断增加，最终引发内存泄漏。

解决方法：在适当的时机，使用 clearInterval 清除定时器。
```

```js
# 保持了对已经删除的DOM元素的引用：
如果你的JavaScript代码中保持了对已经删除的DOM元素的引用，那么这些DOM元素就不会被垃圾回收，从而导致内存泄漏。

未解绑的事件监听器
如果你给DOM元素添加了事件监听器，但没有在适当的时候移除，那么这就可能导致内存泄漏。

var button = document.getElementById('myButton');
button.addEventListener('click', function(event) {
  // 处理点击事件
});
在上述代码中，如果元素 myButton 被删除或替换，但是点击事件的监听器没有被正确移除，那么监听器仍然存在于内存中，导致内存泄漏。

# 解决方法：在元素被删除或不再需要的时候，使用 removeEventListener 将事件监听器移除。
```

```js
# 永不结束的循环：
如果你的代码中有一个永不结束的循环，那么就会持续地消耗内存。

function createObjects() {
  var obj1 = {};
  var obj2 = {};

  obj1.ref = obj2;
  obj2.ref = obj1;
}

createObjects();
在上述代码中，obj1 和 obj2 彼此引用，创建了一个循环引用的情况。即使这些对象超出了函数的作用域，它们仍然无法被垃圾回收器回收。

# 解决方法：在不再需要引用的时候手动解除对象之间的循环引用。
```

```js
# 使用不当的数据结构：
如果你的数据结构（如，使用不当的缓存或无限增长的集合）没有得到正确的清理和管理，那么它们可能会占用大量的内存。
```

```js
# 未使用的对象和数组的属性：
如果你的代码中存在未使用的对象或数组属性，这些属性将不会被垃圾回收，从而可能导致内存泄漏。
```

