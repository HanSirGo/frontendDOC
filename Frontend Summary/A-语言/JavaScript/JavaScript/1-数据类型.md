# 数据类型

## 基本数据类型

```
Number
Boolean
String
Null
Undefined
Symbol(es6,独一无二的值)
BigInt(es10新增)
```

### 存储方式

```
直接存储在栈(stack)中，占据空间小、大小固定、频繁使用,所以放在栈中存储
```

### undefined

```js
可以使用 void 0 代替 undefined
```

![1712481715399](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1712481715399.png)

### 字符串-string

![1710586696955](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1710586696955.png)

![1711881111684](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1711881111684.png)

#### 方法和属性

#####  获取字符串长度

JavaScript中的字符串有一个length属性，该属性可以用来获取字符串的长度：

```
const str = 'hello';str.length   // 输出结果：5
```

##### 获取字符串指定位置的值

> charAt()和charCodeAt()方法都可以通过索引来获取指定位置的值：
>
> - charAt() 方法获取到的是指定位置的字符；
> - charCodeAt()方法获取的是指定位置字符的Unicode值。

###### charAt()

charAt() 方法可以返回指定位置的字符。其语法如下：

```
string.charAt(index)
```

index表示字符在字符串中的索引值：

```
const str = 'hello';str.charAt(1)  // 输出结果：e
```

```
我们知道，字符串也可以通过索引值来直接获取对应字符，那它和charAt()有什么区别呢？来看例子：

const str = 'hello';
str.charAt(1)  // 输出结果：e 
str[1]         // 输出结果：e 
str.charAt(5)  // 输出结果：'' 
str[5]         // 输出结果：undefined

可以看到，当index的取值不在str的长度范围内时，str[index]会返回undefined，而charAt(index)会返回空字符串；除此之外，str[index]不兼容ie6-ie8，charAt(index)可以兼容。
```

###### charCodeAt()

```
`charCodeAt()`：该方法会返回指定索引位置字符的 Unicode 值，返回值是 0 - 65535 之间的整数，表示给定索引处的 UTF-16 代码单元，如果指定位置没有字符，将返回 **NaN**：

let str = "abcdefg";
console.log(str.charCodeAt(1)); // "b" --> 98

通过这个方法，可以获取字符串中指定Unicode编码值范围的字符。比如，数字0～9的Unicode编码范围是: 48～57，可以通过这个方法来筛选字符串中的数字，当然如果你更熟悉正则表达式，会更方便。
```

##### 检索字符串是否包含特定序列

```
这5个方法都可以用来检索一个字符串中是否包含特定的序列。其中前两个方法得到的指定元素的索引值，并且只会返回第一次匹配到的值的位置。后三个方法返回的是布尔值，表示是否匹配到指定的值。

注意：这5个方法都对大小写敏感！
```

###### indexOf()

```js
// indexOf()：查找某个字符，有则返回第一次匹配到的位置，否则返回-1，其语法如下：

string.indexOf(searchvalue,fromindex)

// 该方法有两个参数：

// searchvalue：必须，规定需检索的字符串值；
// fromindex：可选的整数参数，规定在字符串中开始检索的位置。它的合法取值是 0 到 string.length - 1。如省略该，则从字符串的首字符开始检索。

let str = "abcdefgabc";
console.log(str.indexOf("a"));   // 输出结果：0
console.log(str.indexOf("z"));   // 输出结果：-1
console.log(str.indexOf("c", 4)) // 输出结果：9
```

###### lastIndexOf()

```js
// lastIndexOf()：查找某个字符，有则返回最后一次匹配到的位置，否则返回-1

let str = "abcabc";
console.log(str.lastIndexOf("a"));  // 输出结果：3
console.log(str.lastIndexOf("z"));  // 输出结果：-1

// 该方法和indexOf()类似，只是查找的顺序不一样，indexOf()是正序查找，lastIndexOf()是逆序查找。

lastIndexOf
// 从后向前查找对应的字符串片段。
let arr1 = "123"
let idx = arr1.lastIndexOf("1")
console.log(idx);//2
```

###### includes()

```js
// includes()：该方法用于判断字符串是否包含指定的子字符串。如果找到匹配的字符串则返回 true，否则返回 false。该方法的语法如下：

string.includes(searchvalue, start)

// 该方法有两个参数：

// searchvalue：必须，要查找的字符串；
// start：可选，设置从那个位置开始查找，默认为 0。

let str = 'Hello world!';

str.includes('o')  // 输出结果：true
str.includes('z')  // 输出结果：false
str.includes('e', 2)  // 输出结果：false
```

###### startsWith()

```js
// startsWith()：该方法用于检测字符串是否以指定的子字符串开始。如果是以指定的子字符串开头返回 true，否则 false。其语法和上面的includes()方法一样。

let str = 'Hello world!';

str.startsWith('Hello') // 输出结果：true
str.startsWith('Helle') // 输出结果：false
str.startsWith('wo', 6) // 输出结果：true
```

###### endsWith()

```js
// endsWith()：该方法用来判断当前字符串是否是以指定的子字符串结尾。如果传入的子字符串在搜索字符串的末尾则返回 true，否则将返回 false。其语法如下：

string.endsWith(searchvalue, length)

// 该方法有两个参数：

// searchvalue：必须，要搜索的子字符串；
// length：设置字符串的长度，默认值为原始字符串长度 string.length。

let str = 'Hello world!';

str.endsWith('!')       // 输出结果：true
str.endsWith('llo')     // 输出结果：false
str.endsWith('llo', 5)  // 输出结果：true

// 可以看到，当第二个参数设置为5时，就会从字符串的前5个字符中进行检索，所以会返回true。
```

##### 连接多个字符串

######  concat()

```js
// concat() 方法用于连接两个或多个字符串。该方法不会改变原有字符串，会返回连接两个或多个字符串的新字符串。其语法如下：

string.concat(string1, string2, ..., stringX)

// 其中参数 string1, string2, ..., stringX 是必须的，他们将被连接为一个字符串的一个或多个字符串对象。

let str = "abc";
console.log(str.concat("efg"));          //输出结果："abcefg"
console.log(str.concat("efg","hijk")); //输出结果："abcefghijk"

// 虽然concat()方法是专门用来拼接字符串的，但是在开发中使用最多的还是加操作符+，因为其更加简单。
```

##### 字符串分割成数组

###### split()

```js
// split() 方法用于把一个字符串分割成字符串数组。该方法不会改变原始字符串。其语法如下：

string.split(separator,limit)

// 该方法有两个参数：

// separator：必须。字符串或正则表达式，从该参数指定的地方分割 string。
// limit：可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。

let str = "abcdef";
str.split("c");    // 输出结果：["ab", "def"]
str.split("", 4)   // 输出结果：['a', 'b', 'c', 'd'] 

// 如果把空字符串用作 separator，那么字符串中的每个字符之间都会被分割。

str.split("");     // 输出结果：["a", "b", "c", "d", "e", "f"]

// 其实在将字符串分割成数组时，可以同时拆分多个分割符，使用正则表达式即可实现：

const list = "apples,bananas;cherries"
const fruits = list.split(/[,;]/)
console.log(fruits);  // 输出结果：["apples", "bananas", "cherries"]
```

##### 截取字符串

substr()、substring()和 slice() 方法都可以用来截取字符串。

######  slice()

```js
// slice() 方法用于提取字符串的某个部分，并以新的字符串返回被提取的部分。其语法如下：

string.slice(start,end)

// 该方法有两个参数：

// start：必须。要截取的片断的起始下标，第一个字符位置为 0。如果为负数，则从尾部开始截取。
// end：可选。要截取的片段结尾的下标。若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串。如果该参数是负数，那么它规定的是从字符串的尾部开始算起的位置。

// 上面说了，如果start是负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符，-2 指倒数第二个字符，以此类推：

let str = "abcdefg";
str.slice(1,6);   // 输出结果："bcdef" 
str.slice(1);     // 输出结果："bcdefg" 
str.slice();      // 输出结果："abcdefg" 
str.slice(-2);    // 输出结果："fg"
str.slice(6, 1);  // 输出结果：""

// 注意，该方法返回的子串包括开始处的字符，但不包括结束处的字符。
```

###### substr()

```js
// substr() 方法用于在字符串中抽取从开始下标开始的指定数目的字符。其语法如下：

string.substr(start,length)

// 该方法有两个参数：

// start ：必须。要抽取的子串的起始下标。必须是数值。如果是负数，那么该参数声明从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。
// length：可选。子串中的字符数。必须是数值。如果省略了该参数，那么返回从 stringObject 的开始位置到结尾的字串。

let str = "abcdefg";
str.substr(1,6); // 输出结果："bcdefg" 
str.substr(1);   // 输出结果："bcdefg" 相当于截取[1,str.length-1]
str.substr();    // 输出结果："abcdefg" 相当于截取[0,str.length-1]
str.substr(-1);  // 输出结果："g"
```

######  substring()

```js
// substring() 方法用于提取字符串中介于两个指定下标之间的字符。其语法如下：

string.substring(from, to)

// 该方法有两个参数：

// from：必须。一个非负的整数，规定要提取的子串的第一个字符在 string 中的位置。
// to：可选。一个非负的整数，比要提取的子串的最后一个字符在 string 中的位置多 1。如果省略该参数，那么返回的子串会一直到字符串的结尾。

// 注意： 如果参数 from 和 to 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。如果 from 比 to 大，那么该方法在提取子串之前会先交换这两个参数。并且该方法不接受负的参数，如果参数是个负数，就会返回这个字符串。

let str = "abcdefg";
str.substring(1,6); // 输出结果："bcdef" [1,6)
str.substring(1);   // 输出结果："bcdefg" [1,str.length-1]
str.substring();    // 输出结果："abcdefg" [0,str.length-1]
str.substring(6,1); // 输出结果 "bcdef" [1,6)
str.substring(-1);  // 输出结果："abcdefg"

// 注意，该方法返回的子串包括开始处的字符，但不包括结束处的字符。
```

##### 字符串大小写转换

toLowerCase() 和 toUpperCase()方法可以用于字符串的大小写转换。

###### toLowerCase()

```js
// toLowerCase()：该方法用于把字符串转换为小写。

let str = "adABDndj";
str.toLowerCase(); // 输出结果："adabdndj"
```

###### toUpperCase()

```js
// toUpperCase()：该方法用于把字符串转换为大写。

let str = "adABDndj";
str.toUpperCase(); // 输出结果："ADABDNDJ"

// 我们可以用这个方法来将字符串中第一个字母变成大写：

let word = 'apple'
word = word[0].toUpperCase() + word.substr(1)
console.log(word) // 输出结果："Apple"
```

##### 字符串模式匹配

replace()、match()和search()方法可以用来匹配或者替换字符。

###### replace()

```js
// replace()：该方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。其语法如下：

string.replace(searchvalue, newvalue)

// 该方法有两个参数：

// searchvalue：必须。规定子字符串或要替换的模式的 RegExp 对象。如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。
// newvalue：必须。一个字符串值。规定了替换文本或生成替换文本的函数。

let str = "abcdef";
str.replace("c", "z") // 输出结果：abzdef

// 执行一个全局替换, 忽略大小写:

let str="Mr Blue has a blue house and a blue car";
str.replace(/blue/gi, "red");    // 输出结果：'Mr red has a red house and a red car'

// 注意： 如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。
```

```js
# replace 用于查找并替换一个字符串中的一部分为另一个指定的字符串或者一个函数的返回值。

str.replace(regexp|substr, newSubStr|function)
# 特别注意：
# 需要注意的是，replace() 方法返回的是替换后的新字符串，原始字符串并没有被修改。
# 如果需要在原字符串中进行替换，需要将其赋值为新字符串。

# 替换字符串中的某个子串为另一个字符串：
const str = "Hello World!";
const newStr = str.replace("World", "JavaScript");
console.log(newStr); // "Hello JavaScript!"

# 使用正则表达式替换特定的字符或子串：
const str = "Hello, world!";
const newStr = str.replace(/world/i, "JavaScript");
console.log(newStr); // "Hello, JavaScript!"

# 使用函数生成替换后的内容：
const str = "JavaScript is an amazing scripting language!";
const newStr = str.replace(/scripting/g, function(match) {
  return match.toUpperCase();
});
console.log(newStr); // "JavaScript is an amazing SCRIPTING language!"

# 如果replace方法中的参数是变量的情况下不能很好的使用全局替换
// 其中，searchvalue是要替换的字符串，可以是一个变量
str.replace(new RegExp(searchvalue, 'g'), 'w');
```

###### match()

```js
// match()：该方法用于在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值，而不是字符串的位置。其语法如下：

string.match(regexp)

// 该方法的参数 regexp 是必须的，规定要匹配的模式的 RegExp 对象。如果该参数不是 RegExp 对象，则需要首先把它传递给 RegExp 构造函数，将其转换为 RegExp 对象。

// 注意： 该方法返回存放匹配结果的数组。该数组的内容依赖于 regexp 是否具有全局标志 g。

let str = "abcdef";
console.log(str.match("c")) // ["c", index: 2, input: "abcdef", groups: undefined]
```

###### search()

```js
// search()方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。其语法如下：

string.search(searchvalue)

// 该方法的参数 regex 可以是需要在 string 中检索的子串，也可以是需要检索的 RegExp 对象。

// 注意： 要执行忽略大小写的检索，请追加标志 i。该方法不执行全局匹配，它将忽略标志 g，也就是只会返回第一次匹配成功的结果。如果没有找到任何匹配的子串，则返回 -1。

// 返回值： 返回 str 中第一个与 regexp 相匹配的子串的起始位置。

let str = "abcdef";
str.search(/bcd/)   // 输出结果：1
```

##### 移除字符串收尾空白符

trim()、trimStart()和trimEnd()这三个方法可以用于移除字符串首尾的头尾空白符，空白符包括：空格、制表符 tab、换行符等其他空白符等。

###### trim()

```js
// trim() 方法用于移除字符串首尾空白符，该方法不会改变原始字符串：

let str = "  abcdef  "
str.trim()    // 输出结果："abcdef"

// 注意，该方法不适用于null、undefined、Number类型。
```

###### 手写trim()

```js
// 1.
function myTrim(str) {
 return str.replace(/(^\s+)|(\s+$)/g,'')//将前空格和后空格替换为空
}
// 2.
function myTrim(str) {//记录前后空格的个数,最后对字符串进行截取
 let first=0,last=str.length
 for (let i in str) {
  if (str[i]===' ') {
   first++
  } else {
   break
  }
 }
 for (let i=last;i>first;i--) {
  if (str[i]===' ') {
   last--
  } else {
   break
  }
 }
 return str.substr(first,last-first)
}
```



###### trimStart()

```js
// trimStart() 方法的的行为与trim()一致，不过会返回一个从原始字符串的开头删除了空白的新字符串，不会修改原始字符串：

const s = '  abc  ';

s.trimStart()   // "abc  "
```

###### trimEnd()

```js
// trimEnd() 方法的的行为与trim()一致，不过会返回一个从原始字符串的结尾删除了空白的新字符串，不会修改原始字符串：

const s = '  abc  ';

s.trimEnd()   // "  abc"
```

##### 获取字符串本身

valueOf()和toString()方法都会返回字符串本身的值，感觉用处不大。

###### valueOf()

```js
// valueOf()：返回某个字符串对象的原始值，该方法通常由 JavaScript 自动进行调用，而不是显式地处于代码中。

let str = "abcdef"
console.log(str.valueOf()) // "abcdef"
```

###### toString()

```js
// toString()：返回字符串对象本身

let str = "abcdef"
console.log(str.toString()) // "abcdef"
```

##### 重复一个字符串

###### repeat()

```js
// repeat() 方法返回一个新字符串，表示将原字符串重复n次：

'x'.repeat(3)     // 输出结果："xxx"
'hello'.repeat(2) // 输出结果："hellohello"
'na'.repeat(0)    // 输出结果：""

// 如果参数是小数，会向下取整：

'na'.repeat(2.9) // 输出结果："nana"

// 如果参数是负数或者Infinity，会报错：

'na'.repeat(Infinity)   // RangeError
'na'.repeat(-1)         // RangeError

// 如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。

'na'.repeat(-0.9)   // 输出结果：""

// 如果参数是NaN，就等同于 0：

'na'.repeat(NaN)    // 输出结果：""

// 如果repeat的参数是字符串，则会先转换成数字。

'na'.repeat('na')   // 输出结果：""
'na'.repeat('3')    // 输出结果："nanana"
```

##### 补齐字符串长度

padStart()和padEnd()方法用于补齐字符串的长度。如果某个字符串不够指定长度，会在头部或尾部补全。

###### padStart()

```js
// padStart()用于头部补全。该方法有两个参数，其中第一个参数是一个数字，表示字符串补齐之后的长度；第二个参数是用来补全的字符串。

// 如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串：

'x'.padStart(1, 'ab') // 'x'

// 如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串：

'x'.padStart(5, 'ab') // 'ababx'
'x'.padStart(4, 'ab') // 'abax'

// 如果省略第二个参数，默认使用空格补全长度：

'x'.padStart(4) // '   x'

// padStart()的常见用途是为数值补全指定位数，笔者最近做的一个需求就是将返回的页数补齐为三位，比如第1页就显示为001，就可以使用该方法来操作：

"1".padStart(3, '0')   // 输出结果： '001'
"15".padStart(3, '0')  // 输出结果： '015'
```

###### padEnd()

```js
// padEnd()用于尾部补全。该方法也是接收两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串：

'x'.padEnd(5, 'ab') // 'xabab'
'x'.padEnd(4, 'ab') // 'xaba'
```

##### 字符串转为数字

parseInt()和parseFloat()方法都用于将字符串转为数字。

###### parseInt()

```js
// parseInt() 方法用于可解析一个字符串，并返回一个整数。其语法如下：

parseInt(string, radix)

// 该方法有两个参数：

// string：必须。要被解析的字符串。
// radix：可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。


// 当参数 radix 的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。

parseInt("10");     // 输出结果：10
parseInt("17",8);    // 输出结果：15 (8+7)
parseInt("010");    // 输出结果：10 或 8

// 当参数 radix 的值以 “0x” 或 “0X” 开头，将以 16 为基数：

parseInt("0x10")      // 输出结果：16

// 如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN：

parseInt("50", 1)      // 输出结果：NaN
parseInt("50", 40)     // 输出结果：NaN

// 只有字符串中的第一个数字会被返回，当遇到第一个不是数字的字符为止:

parseInt("40 4years")   // 输出结果：40

// 如果字符串的第一个字符不能被转换为数字，就会返回 NaN：

parseInt("new100")     // 输出结果：NaN

// 字符串开头和结尾的空格是允许的：

parseInt("  60  ")    // 输出结果：60
```

###### parseFloat()

```js
// parseFloat() 方法可解析一个字符串，并返回一个浮点数。该方法指定字符串中的首个字符是否是数字。如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，而不是作为字符串。其语法如下：

parseFloat(string)

// parseFloat 将它的字符串参数解析成为浮点数并返回。如果在解析过程中遇到了正负号（+ 或 -）、数字 (0-9)、小数点，或者科学记数法中的指数（e 或 E）以外的字符，则它会忽略该字符以及之后的所有字符，返回当前已经解析到的浮点数。同时参数字符串首位的空白符会被忽略。

parseFloat("10.00")      // 输出结果：10.00
parseFloat("10.01")      // 输出结果：10.01
parseFloat("-10.01")     // 输出结果：-10.01
parseFloat("40.5 years") // 输出结果：40.5

// 如果参数字符串的第一个字符不能被解析成为数字，则 parseFloat 返回 NaN。

parseFloat("new40.5")    // 输出结果：NaN
```

```js
replaceAll
// 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串，该函数会替换所有匹配到的子字符串。
let arr1 = "123124125"
let idx = arr1.replaceAll("2","999")
console.log(idx);//199931999419995
```

#### undefined 与 undeclared 的区别

```js
已在作用域中声明但还没有赋值的变量，是 undefined。相反，还没有在作用域中声明过的变量，是 undeclared 的。

对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typ eof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 "undefined"。
```

#### null 和 undefined 的区别

```js
首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。

undefined 代表的含义是未定义， null 代表的含义是空对象（其实不是真的对象，请看下面的注意！）。一般变量声明了但还没有定义的时候会返回 undefined，null 主要用于赋值给一些可能会返回对象的变量，作为初始化。

其实 null 不是对象，虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。

undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它 会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。

当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等 号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。

// JavaScript 深入理解之 undefined 与 null
```



## 引用数据类型

```
Object,Object本质上是由一组无序的键值对组成,里面包含 Function、Array、Date...
```

### 存储方式

```
同时存储在栈(stack)和堆(heap)中,占据空间大、大小不固定.
	引用数据类型在栈中存储了【指针】,该【指针】指向 【堆】中该实体的【起始地址】;
	当解释器寻找引用值时,会首先检索其在栈中的地址,取得地址后从堆中获取实体.
```

### Array

#### 声明(创建)

```js
# 1. 字面量
// 最常用的创建数组的方式就是数组字面量，数组元素的类型可以是任意的，如下：

let colors = ["red", [1, 2, 3], true];

# 2. 构造函数
// Array 构造函数根据参数长度的不同，有如下两种不同的处理方式：
// **new Array(arg1, arg2,…)**：参数长度为 0 或长度大于等于 2 时，传入的参数将按照顺序依次成为新数组的第 0 至第 N 项（参数长度为 0 时，返回空数组）；
// **new Array(length)**：当 length 不是数值时，返回一个只包含 length 元素一项的数组；当 length 为数值时，length 最大不能超过 32 位无符号整型，即需要小于 2，否则将抛出 RangeError。
// 在使用Array构造函数时，也可以省略 new 操作符，结果是一样的：let array = Array();  

new Array()
	a. 无参数: 返回空数组[]
	b. 一个参数:
    数字 代表长度: new Array(3)// [empty × 3] length:3
	其他类型 代表数组的元素: 
		new Array(undefined) // [undefined] 		
		new Array('abc') //['abc']
	c. 多个参数:
    都是数组的元素:
		new Array(3,2,null) // [3, 2, null] 
```

```js
# 3.ES6 构造器

// 鉴于数组的常用性，ES6 专门扩展了数组构造器 Array ，新增了 2 个方法：Array.of和Array.from。Array.of 用得比较少，Array.from 具有很强的灵活性。

# 1）Array.of

// Array.of 用于将参数依次转化为数组项，然后返回这个新数组。它基本上与 Array 构造器功能一致，唯一的区别就在单个数字参数的处理上。

// 比如，在下面的代码中，可以看到：当参数为2个时，返回的结果是一致的；当参数是一个时，Array.of 会把参数变成数组里的一项，而构造器则会生成长度和第一个参数相同的空数组：

Array.of(8.0); // [8]
Array(8.0); // [empty × 8]

Array.of(8.0, 5); // [8, 5]
Array(8.0, 5); // [8, 5]

Array.of('8'); // ["8"]
Array('8'); // ["8"]

# 2）Array.from

// Array.from 的设计初衷是快速基于其他对象创建新数组，准确来说就是从一个类似数组的可迭代对象中创建一个新的数组实例。其实，只要一个对象有迭代器，Array.from 就能把它变成一个数组（注意：该方法会返回一个的数组，不会改变原对象）。

// 从语法上看，Array.from 有 3 个参数：

// a. 类似数组的对象，必选；
// b. 加工函数，新生成的数组会经过该函数的加工再返回；
// c. this 作用域，表示加工函数执行时 this 的值。

// 这三个参数里面第一个参数是必选的，后两个参数都是可选的：

var obj = {0: 'a', 1: 'b', 2:'c', length: 3};

Array.from(obj, function(value, index){
  console.log(value, index, this, arguments.length);
  return value.repeat(3);   //必须指定返回值，否则返回 undefined
}, obj);
```

> 结果如图：
>
> <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1712390340487.png" alt="1712390340487" style="zoom:67%;" />

```js
// 以上结果表明，通过 Array.from 这个方法可以自定义加工函数的处理方式，从而返回想要得到的值；如果不确定返回值，则会返回 undefined，最终生成的是一个包含若干个 undefined 元素的空数组。

// 实际上，如果这里不指定 this，加工函数就可以是一个箭头函数。上述代码可以简写为以下形式。

Array.from(obj, (value) => value.repeat(3));
//  控制台打印 (3) ["aaa", "bbb", "ccc"]

// 除了上述 obj 对象以外，拥有迭代器的对象还包括 String、Set、Map 等，Array.from 都可以进行处理：

// String
Array.from('abc');                             // ["a", "b", "c"]
// Set
Array.from(new Set(['abc', 'def']));           // ["abc", "def"]
// Map
Array.from(new Map([[1, 'ab'], [2, 'de']]));   // [[1, 'ab'], [2, 'de']]
```

#### 数组空位

```js
// 当我们使用数组字面量初始化数组时，可以使用一串逗号来创建空位，ECMAScript会将逗号之间相应索引位置的值当成空位，ES6 重新定义了该如何处理这些空位。

// 我们可以这样来创建一个空位数组：

let array = [,,,,,];
console.log(array.length);
console.log(array)
```

> 运行结果如下：
>
> ![1712390567254](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1712390567254.png)

```js
// ES6新增的方法和迭代器与早期版本中存在的方法的行为不同，ES6新增方法普遍将这些空位当成存在的元素，只不过值为undefined，使用字面量形式创建如下数组：

let array = [1,,,5];
for(let i of array){
  console.log(i === undefined)
}
// 输出结果：false true true false

// 使用ES6的Array.form创建数组：

let array = Array.from([1,,,5]);
for(let i of array){
  console.log(i === undefined)
}
// 输出结果：false true true false

// 而ES6之前的方法则会忽略这个空位：

let array = [1,,,5];
console.log(array.map(() => 10))

// 输出结果：[10, undefined, undefined, 10]

// 由于不同方法对空位数组的处理方式不同，因此尽量避免使用空位数组。
```

#### 数组索引

在数组中，我们可以通过使用数组的索引来获取数组的值：

```js
let colors = new Array("red", "blue", "green");  
console.log(array[1])  // blue
```

如果指定的索引值小于数组的元素数，就会返回存储在相应位置的元素，也可以通过这种方式来设置一个数组元素的值。如果设置的索引值大于数组的长度，那么就会将数组长度扩充至该索引值加一。

数组长度length的独特之处在于，他不是只读的。通过length属性，可以在数组末尾增加删除元素：

```js
let colors = new Array("red", "blue", "green");  
colors.length = 2
console.log(colors[2])  // undefined

colors.length = 4
console.log(colors[3])  // undefined
```

数组长度始终比数组最后一个值的索引大1，这是因为索引值都是从0开始的。

#### 数组判断

一个很经典的ECMASript问题就是如何判断一个对象是不是数组，下面来看常用的数据类型检测的方法。

在 ES6 之前，至少有如下 5 种方式去判断一个对象是否为数组。

- 通过**Object.prototype.toString.call()** 做判断：

```js
Object.prototype.toString.call(obj).slice(8,-1) === 'Array';
```

- 通过**constructor**做判断：

```js
obj.constructor === Array;
```

- 通过**instanceof**做判断：

```js
obj instanceof Array
```

- 通过**Array.prototype.isPrototypeOf**做判断：

```js
Array.prototype.isPrototypeOf(obj)
```

- 通过基于**getPrototypeOf**做判断：

```js
Object.getPrototypeOf(obj) === Array.prototype;
```

如果obj是一个数组，那么上面这 5 个判断全部为 true，推荐通过 Object.prototype.toString 去判断一个值的类型。

ES6 新增了 `Array.isArray` 方法，可以直接判断数据类型是否为数组：

```js
Array.isArrray(obj);
```

如果 isArray 不存在，那么 `Array.isArray` 的 polyfill 通常可以这样写：

```js
if (!Array.isArray){
  Array.isArray = function(arg){
    return Object.prototype.toString.call(arg) === '[object Array]';
  };
}
```

#### 构造函数静态方法

##### Array.from()

```
Array.from()方法就是将一个类数组对象或者可遍历对象转换成一个真正的数组。
参数：
	第一个参数：类数组等
	第二参数：映射(类似map方法)
	第三参数：作用域
```

```js
1. 将类数组(元素集合、参数集合)对象转换为真正数组

要将一个类数组对象转换成一个真正的数组,必须具备以下条件:
	a. 该类数组对象必须具备length属性,用于指定数组的长度.如果没有length属性,那么转换后的数组是一个空数组
	ps: 转换后的数组的元素的个数=length属性的值
	let obj = { 
		1:'a',
		'2':'b',
        'abc':'c',
		[Symbol('w')]:2,
		length:1
	}
    Array.from(obj) //[undefined]
	b. 该类型数组对象的属性名必须为数值型或者字符串类型的数字;
	let obj = { 
		1:'a',
		'2':'b',
        'abc':'c',
		[Symbol('w')]:2,
		length:4
	}
    Array.from(obj) //[undefined, "a", "b", undefined]
```

```js
2. 将 Set结构的数据转换为真正的数组
let arr = [1,2,3,4]
Array.from(new Set(arr)) // [1,2,3,4]
// 等同于
[... new Set(arr)]
```

```js
3. 将字符串转换为数组:
let str = 'abc';
Array.from(str) // ['a','b','c']
```

```js
4. Array.from参数是一个真正的数组: 返回一个一模一样的数组
let arr = [1,2,3,4]
Array.from(arr) // [1,2,3,4]
```

```js
Array.from还可以接收第二个参数,作用类似于数组的map方法,用来对每个元素进行处理,将处理后的值放入返回的数组
let arr = [1,2,3,4]
Array.from(arr,item => item*2) // [2, 4, 6, 8]
```

```js
Array.from还可以接收第三个参数:作用域
const obj = {
    class: 'A',
    show(el){
        return `我是${this.class}班的${el}`
    }
}
Array.from(['张三','李四'],obj.show,obj) // ["我是A班的张三", "我是A班的李四"]
```

##### Array.of()

```js
Array.of() 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。
Array.of() // []
Array.of(1,null,undefined) // [1, null, undefined]
Array.of([1,2,3]) // [ [1,2,3] ]
Array.of({'a':1}) // [ {'a':1} ]
Array.of({1:'a',2:'b',length:2}) // [ {1:'a',2:'b',length:2} ]
```

> **不论参数是什么都会 返回一个 [] 包裹着参数的数组**

##### Array.isArray()

#### 原型方法

> - 改变原数组的方法：fill()、pop()、push()、shift()、splice()、unshift()、reverse()、sort()；
> - 不改变原数组的方法：concat()、every()、filter()、find()、findIndex()、forEach()、indexOf()、join()、lastIndexOf()、map()、reduce()、reduceRight()、slice()、some。

##### 1. 复制和填充方法

ES提供了两个方法：批量复制方法copeWithin()，以及填充数组方法fill()。这两个方法的签名类似，都需要指定已有数组实例上的一个范围，包含开始索引，不包含结束索引。下面就分别来看一下这两个方法。

##### （1）fill()

使用fill()方法可以向一个已有数组中插入全部或部分相同的值，开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾。如果是负值，则将从负值加上数组的长度而得到的值开始。该方法的语法如下：

```js
array.fill(value, start, end)
```

其参数如下：

- value：必需。填充的值；
- start：可选。开始填充位置；
- end：可选。停止填充位置 (默认为 *array*.length)。

使用示例如下：

```js
const arr = [0, 0, 0, 0, 0];

// 用5填充整个数组
arr.fill(5);
console.log(arr); // [5, 5, 5, 5, 5]
arr.fill(0);      // 重置

// 用5填充索引大于等于3的元素
arr.fill(5, 3);
console.log(arr); // [0, 0, 0, 5, 5]
arr.fill(0);      // 重置

// 用5填充索引大于等于1且小于等于3的元素
arr.fill(5, 3);
console.log(arr); // [0, 5, 5, 0, 0]
arr.fill(0);      // 重置

// 用5填充索引大于等于-1的元素
arr.fill(5, -1);
console.log(arr); // [0, 0, 0, 0, 5]
arr.fill(0);      // 重置
```

##### （2）copyWithin()

copyWithin()方法会按照指定范围来浅复制数组中的部分内容，然后将它插入到指定索引开始的位置，开始与结束索引的计算方法和fill方法一样。该方法的语法如下：

```js
array.copyWithin(target, start, end)
```

其参数如下：

- target：必需。复制到指定目标索引位置；
- start：可选。元素复制的起始位置；
- end：可选。停止复制的索引位置 (默认为 *array*.length)。如果为负值，表示倒数。

使用示例如下：

```js
const array = [1,2,3,4,5]; 
console.log(array.copyWithin(0,3));  // [4, 5, 3, 4, 5]
```

##### 2. 转化方法

数组的转化方法主要有四个：toLocaleString()、toString()、valueOf()、join()。下面就分别来看一下这4个方法。

##### （1）toString()

toString()方法返回的是由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串，也就是说，对数组的每个值都会调用toString()方法，以得到最终的字符串：

```js
let colors = ["red", "blue", "green"];  
console.log(colors.toString())  // red,blue,green
```

##### （2）valueOf()

valueOf()方法返回的是数组本身，如下面代码：

```js
let colors = ["red", "blue", "green"];  
console.log(colors.valueOf())  // ["red", "blue", "green"]
```

##### （3）toLocaleString()

toLocaleString()方法可能会返回和toString()方法相同的结果，但也不一定。在调用toLocaleString()方法时会得到一个逗号分隔的数组值的字符串，它与toString()方法的区别是，为了得到最终的字符串，会调用每个值的toLocaleString()方法，而不是toString()方法，看下面的例子：

```js
let array= [{name:'zz'}, 123, "abc", new Date()];
let str = array.toLocaleString();
console.log(str); // [object Object],123,abc,2016/1/5 下午1:06:23
```

需要注意，如果数组中的某一项是null或者undefined，则在调用上述三个方法后，返回的结果中会以空字符串来表示。

##### （4）join()

join() 方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。其使用语法如下：

```js
arrayObject.join(separator)
```

其中参数separator是可选的，用来指定要使用的分隔符。如果省略该参数，则使用逗号作为分隔符。

该方法返回一个字符串。该字符串是通过把 arrayObject 的每个元素转换为字符串，然后把这些字符串连接起来，在两个元素之间插入 separator 字符串而生成的。

使用示例如下：

```js
let array = ["one", "two", "three","four", "five"];
console.log(array.join());      // one,two,three,four,five
console.log(array.join("-"));   // one-two-three-four-five
```

##### 3. 栈方法

ECMAScript给数组添加了几个方法来使它像栈一样。众所周知，栈是一种后进先出的结构，也就是最近添加的项先被删除。数据项的插入（称为推入，push），和删除（称为弹出，pop）只在栈顶发生。数组提高了push()和pop()来实现类似栈的行为。下面就分别来看看这两个方法。

##### （1）push()

push()方法可以接收任意数量的参数，并将它们添加了数组末尾，并返回数组新的长度。**该方法会改变原数组。** 其语法形式如下：

```js
arrayObject.push(newelement1,newelement2,....,newelementX)
```

使用示例如下：

```js
let array = ["football", "basketball",  "badminton"];
let i = array.push("golfball");
console.log(array); // ["football", "basketball", "badminton", "golfball"]
console.log(i);     // 4
```

##### （2）pop()

pop() 方法用于删除并返回数组的最后一个元素。它没有参数。**该方法会改变原数组。** 其语法形式如下：

```js
arrayObject.pop()
```

使用示例如下：

```js
let array = ["cat", "dog", "cow", "chicken", "mouse"];
let item = array.pop();
console.log(array); // ["cat", "dog", "cow", "chicken"]
console.log(item);  // mouse
```

##### 4. 队列方法

队列是一种先进先出的数据结构，队列在队尾添加元素，在对头删除元素。上面我们已经说了在结果添加数据的方法push()，下面就再来看看从数组开头删除和添加元素的方法：shift()和unshift()。实际上unshift()并不属于操作队列的方法，不过这里也一起说了。

##### （1）shift()

shift()方法会删除数组的第一项，并返回它，然后数组长度减一，**该方法会改变原数组。** 语法形式如下：

```js
arrayObject.shift()
```

使用示例如下：

```js
let array = [1,2,3,4,5];
let item = array.shift();
console.log(array); // [2,3,4,5]
console.log(item);  // 1
```

注意：如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined 值。

##### （2）unshift()

unshift()方法可向数组的开头添加一个或更多元素，并返回新的长度。**该方法会改变原数组。** 其语法形式如下：

```js
arrayObject.unshift(newelement1,newelement2,....,newelementX)
```

使用示例如下：

```js
let array = ["red", "green", "blue"];
let length = array.unshift("yellow");
console.log(array);  // ["yellow", "red", "green", "blue"]
console.log(length); // 4
```

##### 5. 排序方法

数组有两个方法可以对数组进行重新排序：sort()和reverse()。下面就分别来看看这两个方法。

##### （1）sort()

sort()方法是我们常用给的数组排序方法，该方法会在原数组上进行排序，会改变原数组，其使用语法如下：

```
arrayObject.sort(sortby)
```

其中参数sortby是可选参数，用来规定排序顺序，它是一个比较函数，用来判断哪个值应该排在前面。默认情况下，sort()方法会按照升序重新排列数组元素。为此，sort()方法会在每一个元素上调用String转型函数，然后比较字符串来决定顺序，即使数组的元素都是数值，也会将数组元素先转化为字符串在进行比较、排序。这就造成了排序不准确的情况，如下代码：

```js
let array = [5, 4, 3, 2, 1];
let array2 = array.sort();
console.log(array2)  // [1, 2, 3, 4, 5]

let array = [0, 1, 5, 10, 15];
let array2 = array.sort();
console.log(array2)  //  [0, 1, 10, 15, 5]
```

可以看到，上面第二段代码就出现了问题，虽然5是小于10的，但是字符串10在5的前面，所以10还是会排在5前面，因此可知，在很多情况下，不添加参数是不行的。

对于sort()方法的参数，它是一个比较函数，它接收两个参数，如果第一个参数应该排在第二个参数前面，就返回-1；如果两个参数相等，就返回0；如果第一个参数应该排在第二个参数后面，就返回1。一个比较函数的形式可以如下：

```js
function compare(value1, value2) {
 if(value1 < value2){
   return -1
  } else if(value1 > value2){
   return 1
  } else{
   return 0
  }
}

let array = [0, 1, 5, 10, 15];
let array2 = array.sort(compare);
console.log(array2)  // [0, 1, 5, 10, 15]
```

使用箭头函数来定义：

```js
let array = [0, 1, 5, 10, 15];

let array2 = array.sort((a, b) => a - b);  // 正序排序
console.log(array2)  // [0, 1, 5, 10, 15]

let array3 = array.sort((a, b) => b - a);  // 倒序排序
console.log(array3)  // [15, 10, 5, 1, 0]
```

> **语法：**
>
> ```
> arr.sort([compareFunction])
> ```
>
> **参数:**
>
> ```
> compareFunction [可选]
> ```
>
> 用于数组排序规则的比较函数。
>
> 如果不含有该参数，数组元素按照转换字符串的各个字符的Unicode编码顺序进行排序。
>
> compareFunction 参数：
>
> - • firstElement 用于比较的第一个元素
> - • secondElement 用于比较的第二个元素
>
> **返回值:**
>
> 排序后的数组，返回的是当前数组。

```js
# 没有参数的默认排序
// 当没有参数传入时 默认按照数组转成字符串后的结果每一位的Unicode编码进行排序
let arr = [311,43,54,4,40,26,31,33];
arr.sort();
console.log(arr); // [26, 31, 311, 33, 4, 40, 43, 54]

# 降序排列
let arr = [311,43,54,4,40,26,31,33];
arr.sort((a,b) => b - a);
console.log(arr); // [311, 54, 43, 40, 33, 31, 26, 4]

# 升序排列
let arr = [311,43,54,4,40,26,31,33];
arr.sort((a,b) => a - b);
console.log(arr); //  [4, 26, 31, 33, 40, 43, 54, 311]
```

> **排序的规则**
>
> 如果添加了 compareFunction 那么数组会按该函数的返回值结果进行排序。
>
> 即 compareFunction(a,b) 表示 a,b的比较结果，规则如下：
>
> - • 如果返回值结果小于0，则a和b的顺序不变;
> - • 如果返回值结果等于0，则a和b的顺序不变;
> - • 如果返回值的结果大于0，a和b会交换位置。

```js
# 颠倒数组的顺序
let arr = [311,43,54,4,40,26,31,33];
arr.sort(() => -1);
console.log(arr); // [33, 31, 26, 40, 4, 54, 43, 311]

# 随机排序
let arr = [311,43,54,4,40,26,31,33];
arr.sort((a,b) => Math.random() - 0.5);
console.log(arr); // 结果为随机排序

# 先按奇数升序排列，后按偶数升序排列
let arr = [311,43,54,4,40,26,31,33];
arr.sort((a,b)=>{
    if(!(a % 2) && b % 2) return 1; // 首先满足条件a为偶数,b为奇数
    if((a % 2 && b % 2 || !(a % 2) && !(b % 2)) && a > b) return 1; // 判断a b 均为奇数或偶数 且a > b 即可进行升序排序
    return -1;
});
console.log(arr); // [31, 33, 43, 311, 4, 26, 40, 54]
```

##### （2）reverse()

reverse() 方法用于颠倒数组中元素的顺序。该方法会改变原来的数组，而不会创建新的数组。其使用语法如下：

```
arrayObject.reverse()
```

使用示例如下：

```js
let array = [1,2,3,4,5];
let array2 = array.reverse();
console.log(array);   // [5,4,3,2,1]
console.log(array2 === array);   // true
```

##### 6. 操作方法

对于数组，还有很多操作方法，下面我们就来看看常用的concat()、slice()、splice()方法。

##### （1）concat()

concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。其适用语法如下：

```js
arrayObject.concat(arrayX,arrayX,......,arrayX)
```

其中参数arrayX是必需的。该参数可以是具体的值，也可以是数组对象。可以是任意多个。

使用示例如下：

```js
let array = [1, 2, 3];
let array2 = array.concat(4, [5, 6], [7, 8, 9]);
console.log(array2); // [1, 2, 3, 4, 5, 6, 7, 8, 9]
console.log(array);  // [1, 2, 3], 可见原数组并未被修改
```

该方法还可以用于数组扁平化，后面会介绍。

##### （2）slice()

slice() 方法可从已有的数组中返回选定的元素。返回一个新的数组，包含从 start 到 end （不包括该元素）的数组元素。方法并不会修改数组，而是返回一个子数组。其使用语法如下：

```js
arrayObject.slice(start,end)
```

其参数如下：

- **start**：必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推；
- **end**：可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。

使用示例如下：

```js
let array = ["one", "two", "three", "four", "five"];
console.log(array.slice(0));    // ["one", "two", "three","four", "five"]
console.log(array.slice(2,3)); // ["three"]
```

##### （3）splice()

splice()方法可能是数组中的最强大的方法之一了，使用它的形式有很多种，它会向/从数组中添加/删除项目，然后返回被删除的项目。该方法会改变原始数组。其使用语法如下：

```js
arrayObject.splice(index, howmany, item1,.....,itemX)
```

其参数如下：

- index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。
- howmany：必需。要删除的项目数量。如果设置为 0，则不会删除项目。
- item1, ..., itemX：可选。向数组添加的新项目。

从上面参数可知，splice主要有三种使用形式：

- **删除：** 需要给splice()传递两个参数，即要删除的第一个元素的位置和要删除的元素的数量；
- **插入：** 需要给splice()传递至少三个参数，即开始位置、0（要删除的元素数量）、要插入的元素。
- **替换：** splice()方法可以在删除元素的同事在指定位置插入新的元素。同样需要传入至少三个参数，即开始位置、要删除的元素数量、要插入的元素。要插入的元素数量是任意的，不一定和删除的元素数量相等。

使用示例如下：

```js
let array = ["one", "two", "three","four", "five"];
console.log(array.splice(1, 2));           // 删除：["two", "three"]

let array = ["one", "two", "three","four", "five"];
console.log(array.splice(2, 0, 996));      // 插入：[]

let array = ["one", "two", "three","four", "five"];
console.log(array.splice(2, 1, 996));      // 替换：["three"]
```

##### 7. 归并方法

ECMAScript为数组提供了两个归并方法：reduce()和reduceRight()。下面就分别来看看这两个方法。

##### （1）reduce()

reduce() 方法对数组中的每个元素执行一个reducer函数(升序执行)，将其结果汇总为单个返回值。其使用语法如下：

```js
arr.reduce(callback,[initialValue])
```

reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。(1) `callback` （执行数组中每个值的函数，包含四个参数）

- previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue））
- currentValue （数组中当前被处理的元素）
- index （当前元素在数组中的索引）
- array （调用 reduce 的数组）

(2) `initialValue` （作为第一次调用 callback 的第一个参数。）

```js
let arr = [1, 2, 3, 4]
let sum = arr.reduce((prev, cur, index, arr) => {
    console.log(prev, cur, index);
    return prev + cur;
})
console.log(arr, sum);  
```

输出结果如下：

```js
1 2 1
3 3 2
6 4 3
[1, 2, 3, 4] 10
```

再来加一个初始值看看：

```js
let arr = [1, 2, 3, 4]
let sum = arr.reduce((prev, cur, index, arr) => {
    console.log(prev, cur, index);
    return prev + cur;
}, 5)
console.log(arr, sum);  
```

输出结果如下：

```js
5 1 0
6 2 1
8 3 2
11 4 3
[1, 2, 3, 4] 15
```

通过上面例子，可以得出结论：**如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。**

注意，该方法如果添加初始值，就会改变原数组，将这个初始值放在数组的最后一位。

```js
# （1）数组求和
// reduce()方法最直接的用法就是对数组元素求和：

const total = [34, 12, 143, 13, 76].reduce(
  (previousValue, currentValue) => previousValue + currentValue,
  0
);
console.log(total);

// 其输出结果如下：
278

# （2）扁平数组
// reduce()方法还可以用来扁平化数组：

const array = [[0, 1], [2, 3], [4, 5], [5, 6]];

const flattenedArray = array.reduce(
  (previousValue, currentValue) => previousValue.concat(currentValue),
  []
);
console.log(flattenedArray);
// 输出结果如下：
[0, 1, 2, 3, 4, 5, 5, 6]
// 如果数组有不止一层嵌套数组，可以递归调用 reduce 函数来扁平化，然后将它们与最终的数组连接起来即可。

const nestedArray = [[1, [2, 3]], [4, 5], [[6, 7], [8, 9]]];

function flattenArray(nestedArray) {
  return nestedArray.reduce(
    (accumulator, currentValue) => 
      accumulator.concat(
        Array.isArray(currentValue) ? flattenArray(currentValue) : currentValue
      ),
    []);
}

const flattenedArray = flattenArray(nestedArray);
console.log(flattenedArray)

// 输出结果如下：
[1, 2, 3, 4, 5, 6, 7, 8, 9]

# （3）数组分组
// 假设有一个国家对象数组，根据国家所在洲对数组中的每个国家进行分组。可以使用 reduce 方法来完成：

cosnt countries = [
    {name: "Germany", continent: "Europe"},
    {name: "Brazil", continent: "South America"},
    {name: "India", continent: "Asia"},
    {name: "France", continent: "Europe"},
    {name: "South Korea", continent: "Asia"},
]

const groupedCountries = countries.reduce(
  (groupedCountries, country) => {
    if (!groupedCountries[country.continent]){
      groupedCountries[country.continent] = []
    }
    groupedCountries[country.continent].push(country)
    return groupedCountries
  },
  {}
);
console.log(groupedCountries)

# （4）使用 reduce() 代替 filter().map()
// 在 Javascript 中，数组的 filter 方法可以通过回调过滤数组中的元素，map 方法可以通过回调内部传递的逻辑使用旧数组创建一个新数组。有时我们必须同时使用这两种方法，对某些条件过滤的结果创建一个新数组。

// 可以使用 reduce 方法来完成相同的工作，这样就只需要遍历数组一次。例如，要创建一个大于 30 的数字的平方根数组，使用 filter().map() 可能会这么写：

const numbers = [3, 21, 34, 121, 553, 12, 53, 5, 42, 11];

const newArray = numbers.filter(number => number > 30).map(number => Math.sqrt(number));
使用 reduce 实现：

const numbers = [3, 21, 34, 121, 553, 12, 53, 5, 42, 11];

const newArray = numbers.reduce((previousValue, currentValue) => {
  if (currentValue > 30) {
    previousValue.push(Math.sqrt(currentValue))
  }
  return previousValue
}, []);

console.log(newArray);

// 输出结果如下：
 [5.830951894845301, 11, 23.515952032609693, 7.280109889280518, 6.48074069840786]

# （5）统计数组元素出现次数
// 可以使用reduce来统计数组中每个元素出现的次数：

const colors = ['green', 'red', 'red', 'yellow', 'red', 'yellow', 'green', 'green'];

const colorMap = colors.reduce((previousValue, currentValue) => {
    previousValue[currentValue] >= 1 ? previousValue[currentValue]++ : previousValue[currentValue] = 1;
    return previousValue;
  }, 
  {}
);

console.log(colorMap);
// 输出结果如下：
{green: 3, red: 3, yellow: 2}

# （6）串行执行异步函数
// 有一组需要串行执行的异步函数，可以使用reduce()来调用执行：

const functions = [
  async function() { return 1; },
  async function() { return 2; },
  async function() { return 3; }
];

const res = await functions.reduce((promise, fn) => promise.then(fn), Promise.resolve());

console.log(res);  // 输出结果：3
// 这里的 res 就相当于执行了：

Promise.resolve().then(fn1).then(fn2).then(fn3);

# （7）创建管道
// 假设有一组简单的数学函数，这些函数允许我们增加、减少、加倍和减半：

function increment(input) { return input + 1;}

function decrement(input) { return input — 1; }

function double(input) { return input * 2; }

function halve(input) { return input / 2; }

// 如果想对一个值进行多次上述操作，就可以使用reduce()。管道是用于将某些初始值转换为最终值的函数列表的术语。我们只需将执行过程中每一步用到函数写在管道数组中即可。

const pipeline = [increment, double, decrement];

const result = pipeline.reduce((total, func) => {
  return func(total);
}, 5);

console.log(result) // 输出结果：11

# （8）反转字符串
// 可以使用reduce()实现字符串的反转：

const str = 'hello world';

[...str].reduce((a,v) => v + a);  // 输出结果：'dlrow olleh'

# （9）数组去重
// 有一个包含重复项的数组，可以使用 reduce() 来对数组进行去重：

const arr = ["🚀", "🚀", "🚀", "🌍"];

const dedupe = (acc, currentValue) => {
  if (!acc.includes(currentValue)) {
    acc.push(currentValue);
  }
  return acc;
};

const dedupedArr = arr.reduce(dedupe, []); 

console.log(dedupedArr);  // ["🚀", "🌍"];

// 当 reduce 方法遍历数组时，回调函数将应用于数组中的每一项。它会检查累加器中是否缺少当前值，如果是，则将当前值 push 到累加器中。

// 注：此示例仅用于说明 reduce 方法的工作原理，在实践中，通常会选择使用 Set 对数组进行去重，这是一种性能更高的方法：

dedupedArr = [...new Set(array)];
```



```js
// api用法:

arr.reduce(function(prev, cur, index, arr){}, initialValue)
```

```js
// 手写实现:

Array.prototype.myReduce=function(fn,init_val){
 let [val,idx]=init_val?[init_val,0]:[this[0],1]//设置初始值
 for (let i=idx,len=this.length;i<len;i++) {
  val=fn(val,this[i],i,this)//循环并迭代结果
 }
 return val
}

console.log([1,2,3,4,5].reduce((pre,item)=>pre+item,0)) // 15
```

##### （2）reduceRight()

该方法和的上面的`reduce()`用法几乎一致，只是该方法是对数组进行倒序查找的。而`reduce()`方法是正序执行的。

```js
let arr = [1, 2, 3, 4]
let sum = arr.reduceRight((prev, cur, index, arr) => {
    console.log(prev, cur, index);
    return prev + cur;
}, 5)
console.log(arr, sum);
```

输出结果如下：

```js
5 4 3
9 3 2
12 2 1
14 1 0
[1, 2, 3, 4] 15
```

##### 8. 搜索和位置方法

ECMAScript提供了两类搜索数组的方法：按照严格相等搜索和按照断言函数搜索。

##### （1）严格相等 indexOf()、lastIndexOf()、includes()

ECMAScript通过了3个严格相等的搜索方法：indexOf()、lastIndexOf()、includes()。这些方法都接收两个参数：要查找的元素和可选的其实搜索位置。lastIndexOf()方法会从数组结尾元素开始向前搜索，其他两个方法则会从数组开始元素向后进行搜索。indexOf()和lastIndexOf()返回的是查找元素在数组中的索引值，如果没有找到，则返回-1。includes()方法会返回布尔值，表示是否找到至少一个与指定元素匹配的项。在比较第一个参数和数组的每一项时，会使用全等（===）比较，也就是说两项必须严格相等。

使用示例如下：

```js
let arr = [1, 2, 3, 4, 5];
console.log(arr.indexOf(2))      // 1
console.log(arr.lastIndexOf(3))  // 2
console.log(arr.includes(4))     // true
```

##### （2）断言函数 find()、findIndex()

ECMAScript也允许按照定义的断言函数搜索数组，每个索引都会调用这个函数，断言函数的返回值决定了相应索引的元素是否被认为匹配。使用断言函数的方法有两个，分别是find()和findIndex()方法。这两个方法对于空数组，函数是不会执行的。并且没有改变数组的原始值。他们的都有三个参数：元素、索引、元素所属的数组对象，其中元素是数组中当前搜索的元素，索引是当前元素的索引，而数组是当前正在搜索的数组。

这两个方法都从数组的开始进行搜索，find()返回的是第一个匹配的元素，如果没有符合条件的元素返回 undefined；findIndex()返回的是第一个匹配的元素的索引，如果没有符合条件的元素返回 -1。

使用示例如下：

```js
let arr = [1, 2, 3, 4, 5]
arr.find(item => item > 2)      // 结果：3
arr.findIndex(item => item > 2) // 结果：2
```

##### 9. 迭代器方法

##### （1）keys()、values()、entries()

在ES6中，Array的原型上暴露了3个用于检索数组内容的方法：keys()、values()、entries()。keys()方法返回数组索引的迭代器，values()方法返回数组元素的迭代器，entries()方法返回索引值对的迭代器。

使用示例如下（因为这些方法返回的都是迭代器，所以可以将他们的内容通过Array.from直接转化为数组实例）：

```js
let array = ["one", "two", "three", "four", "five"];
console.log(Array.from(array.keys()))     // [0, 1, 2, 3, 4]
console.log(Array.from(array.values()))   // ["one", "two", "three", "four", "five"]
console.log(Array.from(array.entries()))  // [[0, "one"], [1, "two"], [2, "three"], [3, "four"], [4, "five"]]
```

##### 10. 迭代方法

ECMAScript为数组定义了5个迭代方法，分别是every()、filter()、forEach()、map()、some()。这些方法都不会改变原数组。这五个方法都接收两个参数：以每一项为参数运行的函数和可选的作为函数运行上下文的作用域对象（影响函数中的this值）。传给每个方法的函数接收三个参数，分别是当前元素、当前元素的索引值、当前元素所属的数对象。

##### （1）forEach()

`forEach` 方法用于调用数组的每个元素，并将元素传递给回调函数。该方法没有返回值，使用示例如下：

```js
let arr = [1,2,3,4,5]
arr.forEach((item, index, arr) => {
  console.log(index+":"+item)
})
```

该方法还可以有第二个参数，用来绑定回调函数内部this变量（回调函数不能是箭头函数，因为箭头函数没有this）：

```js
let arr = [1,2,3,4,5]
let arr1 = [9,8,7,6,5]
arr.forEach(function(item, index, arr){
  console.log(this[index])  //  9 8 7 6 5
}, arr1)
```

##### （2）map()

`map()` 方法会返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。该方法按照原始数组元素顺序依次处理元素。该方法不会对空数组进行检测，它会返回一个新数组，**不会改变原始数组**。使用示例如下：

```js
let arr = [1, 2, 3];
 
arr.map(item => {
    return item+1;
})
// 结果： [2, 3, 4]
```

第二个参数用来绑定参数函数内部的this变量：

```js
var arr = ['a', 'b', 'c'];
 
[1, 2].map(function (e) {
    return this[e];
}, arr)
 // 结果： ['b', 'c']
```

该方法可以进行链式调用：

```js
let arr = [1, 2, 3];
 
arr.map(item => item+1).map(item => item+1)
 // 结果： [3, 4, 5]
```

```
forEach方法是一种流行的数组迭代工具。它为每个数组元素执行一次提供的函数。但是，与传统的for 和 while循环不同，forEach它被设计为对每个元素执行该函数，没有内置机制来提前停止或中断循环。
```

```js
const fruits = ["apple", "banana", "cherry"];
fruits.forEach(function(fruit) {
  console.log(fruit); // apple banana cherry
});
```

```js
// 手写实现:

Array.prototype.myForEach=function(fn,temp_this) {
    for (let i=0,len=this.length;i<len;i++){
        fn.call(temp_this,this[i],i,this)//循环数组元素,为回调函数传入参数
    }
}
```

###### 如何终止 forEach

> a. 利用 break

```js
forEach 的一个关键限制是无法使用传统的控制语句（如break或return）来停止或中断循环。 如果你尝试在 forEach 中使用break，您将遇到语法错误，因为break在回调函数中不适用。

const numbers = [1, 2, 3, 4, 5];
numbers.forEach(number => {
  if (number > 3) {
    break; // Syntax Error: Illegal break statement
  }
  console.log(number);
});
```

> b. 利用 return

```js
在其他循环或函数中，return 语句退出循环或函数，并返回一个值（如果指定）。

在 forEach 的上下文中，return 不会跳出循环。 相反，它只是退出回调函数的当前迭代并移至数组中的下一个元素。

const numbers = [1, 2, 3, 4, 5];
numbers.forEach(number => {
  if (number === 3) {
    return; // Exits only the current iteration
  }
  console.log(number); // 1、2、4、5
});
return 跳过 3 的打印，但循环继续处理剩余元素。
```

> c. 使用Error终止 forEach

```js
虽然不建议这么使用，但从技术上讲，可以通过抛出异常来停止 forEach 循环。 这种方法虽然是非正统的，并且由于影响代码可读性和错误处理而通常建议不要这样做，但它可以有效地停止循环。

const numbers = [1, 2, 3, 4, 5];
try {
  numbers.forEach(number => {
    if (number > 3) {
      throw new Error('循环停止');
    }
    console.log(number);
  });
} catch (e) {
  console.log('出现异常，循环已停止');
}
// 输出: 1, 2, 3, 出现异常，循环已停止
在此示例中，当满足条件时，将引发异常，从而提前退出 forEach 循环。 但是，需要注意，你得正确处理此类异常以避免产生意外的副作用。
```

> d. 使用 for...of 循环 代替 forEach

```js
ES6 (ECMAScript 2015) 中引入的 for...of 循环提供了一种现代、干净且可读的方式来迭代可迭代对象，例如数组、字符串、映射、集合等。

与 forEach 相比，它的主要优势在于它与 Break 和 continue 等控制语句的兼容性，为循环控制提供了更大的灵活性。

const numbers = [1, 2, 3, 4, 5];

for (const number of numbers) {
  if (number > 3) {
    break; // 成功终止循环
  }
  console.log(number); // 1 2 3
}
在此示例中，循环迭代numbers 数组中的每个元素。 一旦遇到大于3的数字，它就会使用break语句退出循环。 forEach 无法实现这种级别的控制。
```

```
总结:
虽然 JavaScript 中的 forEach 方法提供了一种简单的数组迭代方法，但它缺乏中断或停止中循环的灵活性。

幸运的是，像 for...of 循环这样的替代方法，以及像 some() 和 every() 这样的方法，可以替代 forEach。
```



###### forEach和map区别如下：

- forEach()方法：会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；
- map()方法：不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；

##### （3）filter()

`filter()`方法用于过滤数组，满足条件的元素会被返回。它的参数是一个回调函数，所有数组元素依次执行该函数，返回结果为true的元素会被返回。该方法会返回一个新的数组，不会改变原数组。

```js
let arr = [1, 2, 3, 4, 5]
arr.filter(item => item > 2) 
// 结果：[3, 4, 5]
```

可以使用`filter()`方法来移除数组中的undefined、null、NAN等值

```js
let arr = [1, undefined, 2, null, 3, false, '', 4, 0]
arr.filter(Boolean)
// 结果：[1, 2, 3, 4]
```

##### （4）every()

该方法会对数组中的每一项进行遍历，只有所有元素都符合条件时，才返回true，否则就返回false。

```js
let arr = [1, 2, 3, 4, 5]
arr.every(item => item > 0) 
// 结果：true
```

##### （5）some()

该方法会对数组中的每一项进行遍历，只要有一个元素符合条件，就返回true，否则就返回false。

```js
let arr = [1, 2, 3, 4, 5]
arr.some(item => item > 4) 
// 结果：true
```

##### 11. 其他方法

除了上述方法，遍历数组的方法还有for...in和for...of。下面就来简单看一下。

##### （1）for…in

`for…in` 主要用于对数组或者对象的属性进行循环操作。循环中的代码每执行一次，就会对对象的属性进行一次操作。其使用语法如下：

```js
for (var item in object) {
  执行的代码块
}
```

其中两个参数：

- item：必须。指定的变量可以是数组元素，也可以是对象的属性。
- object：必须。指定迭代的的对象。

使用示例如下：

```js
const arr = [1, 2, 3]; 
 
for (var i in arr) { 
    console.log('键名：', i); 
    console.log('键值：', arr[i]); 
}
```

输出结果如下：

```js
键名： 0
键值： 1
键名： 1
键值： 2
键名： 2
键值： 3
```

需要注意，该方法**不仅会遍历当前的对象所有的可枚举属性，还会遍历其原型链上的属性。** 除此之外，该方法遍历数组时候，遍历出来的是数组的索引值，遍历对象的时候，遍历出来的是键值名。

##### （2）for...of

`for...of` 语句创建一个循环来迭代可迭代的对象。在 ES6 中引入的 `for...of` 循环，以替代 `for...in` 和 `forEach()` ，并支持新的迭代协议。`for...of` 允许遍历 Arrays（数组）, Strings（字符串）, Maps（映射）, Sets（集合）等可迭代的数据结构等。

语法：

```js
for (var item of iterable) {
    执行的代码块
}
```

其中两个参数：

- item：每个迭代的属性值被分配给该变量。
- iterable：一个具有可枚举属性并且可以迭代的对象。

该方法允许获取对象的键值：

```js
var arr = ['a', 'b', 'c', 'd'];
for (let a in arr) {
  console.log(a); // 0 1 2 3
}
for (let a of arr) {
  console.log(a); // a b c d
}
```

该方法只会遍历当前对象的属性，不会遍历其原型链上的属性。

**注意：**

- for...of适用遍历 **数组/ 类数组/字符串/map/set** 等拥有迭代器对象的集合；
- 它可以正确响应break、continue和return语句；
- for...of循环不支持遍历普通对象，因为没有迭代器对象。如果想要遍历一个对象的属性，可以用`for-in`循环。

###### 区别

**总结，for…of 和for…in的区别如下：**

- for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；
- for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；
- 对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；

##### （3）flat()

在ES2019中，flat()方法用于创建并返回一个新数组，这个新数组包含与它调用flat()的数组相同的元素，只不过其中任何本身也是数组的元素会被打平填充到返回的数组中：

```js
[1, [2, 3]].flat()   // [1, 2, 3]
[1, [2, [3, 4]]].flat()   // [1, 2, [3, 4]]
```

在不传参数时，flat()默认只会打平一级嵌套，如果想要打平更多的层级，就需要传给flat()一个数值参数，这个参数表示要打平的层级数：

```js
[1, [2, [3, 4]]].flat(2)   // [1, 2, 3, 4]
```

##### （4）flatMap

```js
flatMap() 方法将 map() 和 flat() 的效果结合到一个方法中。

const numbers = [1, 2, 3];
const doubledAndFlattened = numbers.flatMap(num => [num * 2]);

console.log(doubledAndFlattened); // [2, 4, 6]
```

```js
// 手动实现 Array.prototype.map 方法
map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。

function map(arr, mapCallback) {
  // 首先，检查传递的参数是否正确。
  if (!Array.isArray(arr) || !arr.length || typeof mapCallback !== 'function') { 
    return [];
  } else {
    let result = [];
    // 每次调用此函数时，我们都会创建一个 result 数组
    // 因为我们不想改变原始数组。
    for (let i = 0, len = arr.length; i < len; i++) {
      result.push(mapCallback(arr[i], i, arr)); 
      // 将 mapCallback 返回的结果 push 到 result 数组中
    }
    return result;
  }
}

// 手动实现Array.prototype.filter方法
filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。

function filter(arr, filterCallback) {
  // 首先，检查传递的参数是否正确。
  if (!Array.isArray(arr) || !arr.length || typeof filterCallback !== 'function') 
  {
    return [];
  } else {
    let result = [];
     // 每次调用此函数时，我们都会创建一个 result 数组
     // 因为我们不想改变原始数组。
    for (let i = 0, len = arr.length; i < len; i++) {
      // 检查 filterCallback 的返回值是否是真值
      if (filterCallback(arr[i], i, arr)) { 
      // 如果条件为真，则将数组元素 push 到 result 中
        result.push(arr[i]);
      }
    }
    return result; // return the result array
  }
}

// 手动实现Array.prototype.reduce方法
reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。


function reduce(arr, reduceCallback, initialValue) {
  // 首先，检查传递的参数是否正确。
  if (!Array.isArray(arr) || !arr.length || typeof reduceCallback !== 'function') 
  {
    return [];
  } else {
    // 如果没有将initialValue传递给该函数，我们将使用第一个数组项作为initialValue
    let hasInitialValue = initialValue !== undefined;
    let value = hasInitialValue ? initialValue : arr[0];
   、

    // 如果有传递 initialValue，则索引从 1 开始，否则从 0 开始
    for (let i = hasInitialValue ? 1 : 0, len = arr.length; i < len; i++) {
      value = reduceCallback(value, arr[i], i, arr); 
    }
    return value;
  }
}
```



#### 类数组对象

JavaScript 中一直存在一种类数组的对象，它们不能直接调用数组的方法，但是又和数组比较类似，在某些特定的编程场景中会出现，下面就来看一下什么是类数组。

在 JavaScript 中，主要有以下情况中的对象是类数组：

- 函数里面的参数对象 arguments；
- 用 getElementsByTagName/ClassName/Name 获得的 HTMLCollection；
- 用 querySelector 获得的 NodeList。

##### （1）arguments

在日常开发中经常会遇到各种类数组对象，最常见的就是在函数中使用的 arguments，它的对象只定义在函数体中，包括了函数的参数和其他属性。先来看下 arguments 的使用方法：

```js
function foo(name, age, sex) {
    console.log(arguments);
    console.log(typeof arguments);
    console.log(Object.prototype.toString.call(arguments));
}
foo('jack', '18', 'male');
```

打印结果如下：![1712392851980](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1712392851980.png)可以看到，typeof 这个 arguments 返回的是 object，通过 Object.prototype.toString.call 返回的结果是 [object arguments]，而不是 [object array]，说明 arguments 和数组还是有区别的。

length 属性就是函数参数的长度。另外 arguments 还有一个 callee 属性，下面看看这个 callee 是干什么的：

```js
function foo(name, age, sex) {
    console.log(arguments.callee);
}

foo('jack', '18', 'male');
```

打印结果如下：

```js
ƒ foo(name, age, sex) {
    console.log(arguments.callee);
}
```

可以看出，输出的就是函数自身，如果在函数内部直接执行调用 callee，那它就会不停地执行当前函数，直到执行到内存溢出。

##### （2）HTMLCollection

HTMLCollection 简单来说是 HTML DOM 对象的一个接口，这个接口包含了获取到的 DOM 元素集合，返回的类型是类数组对象，如果用 typeof 来判断的话，它返回的是 object。它是及时更新的，当文档中的 DOM 变化时，它也会随之变化。

下面来 HTMLCollection 最后返回的是什么，在一个**有 form 表单**的页面中，在控制台中执行下述代码：

```js
var elem1, elem2;
// document.forms 是一个 HTMLCollection
elem1 = document.forms[0];
elem2 = document.forms.item(0);
console.log(elem1);
console.log(elem2);
console.log(typeof elem1);
console.log(Object.prototype.toString.call(elem1));
```

打印结果如下：![1712392901207](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1712392901207.png)

可以看到，这里打印出来了页面第一个 form 表单元素，同时也打印出来了判断类型的结果，说明打印的判断的类型和 arguments 返回的也比较类似，typeof 返回的都是 object，和上面的类似。

注意：HTML DOM 中的 HTMLCollection 是即时更新的，当其所包含的文档结构发生改变时，它会自动更新。

##### （3）NodeList

NodeList 对象是节点的集合，通常是由 querySlector 返回的。NodeList 不是一个数组，也是一种类数组。虽然 NodeList 不是一个数组，但是可以使用 for...of 来迭代。在一些情况下，NodeList 是一个实时集合，也就是说，如果文档中的节点树发生变化，NodeList 也会随之变化。

```js
var list = document.querySelectorAll('input[type=checkbox]');
for (var checkbox of list) {
  checkbox.checked = true;
}
console.log(list);
console.log(typeof list);
console.log(Object.prototype.toString.call(list));
```

打印结果如下：![1712392923298](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1712392923298.png)

##### 类数组转为数组

```js
# （1）借用数组方法

// 类数组因为不是真正的数组，所以没有数组类型上自带的那些方法，所以就需要利用下面这几个方法去借用数组的方法。比如借用数组的 push 方法，代码如下：

var arrayLike = { 
  0: 'java',
  1: 'script',
  length: 2
} 
Array.prototype.push.call(arrayLike, 'jack', 'lily'); 
console.log(typeof arrayLike); // 'object'
console.log(arrayLike);
// {0: "java", 1: "script", 2: "jack", 3: "lily", length: 4}

// 可以看到，arrayLike 其实是一个对象，模拟数组的一个类数组，从数据类型上说它是一个对象，新增了一个 length 的属性。还可以看出，用 typeof 来判断输出的是 object，它自身是不会有数组的 push 方法的，这里用 call 的方法来借用 Array 原型链上的 push 方法，可以实现一个类数组的 push 方法，给 arrayLike 添加新的元素。

// 从打印结果可以看出，数组的 push 方法满足了我们想要实现添加元素的诉求。再来看下 arguments 如何转换成数组：

function sum(a, b) {
  let args = Array.prototype.slice.call(arguments);
 // let args = [].slice.call(arguments); // 这样写也是一样效果
  console.log(args.reduce((sum, cur) => sum + cur));
}
sum(1, 2);  // 3
function sum(a, b) {
  let args = Array.prototype.concat.apply([], arguments);
  console.log(args.reduce((sum, cur) => sum + cur));
}
sum(1, 2);  // 3

// 可以看到，借用 Array 原型链上的各种方法，来实现 sum 函数的参数相加的效果。一开始都是将 arguments 通过借用数组的方法转换为真正的数组，最后都又通过数组的 reduce 方法实现了参数转化的真数组 args 的相加，最后返回预期的结果。

# （2）借用ES6方法

// 还可以采用 ES6 新增的 Array.from 方法以及展开运算符的方法来将类数组转化为数组。那么还是围绕上面这个 sum 函数来进行改变，看下用 Array.from 和展开运算符是怎么实现转换数组的：

function sum(a, b) {
  let args = Array.from(arguments);
  console.log(args.reduce((sum, cur) => sum + cur));
}
sum(1, 2);    // 3
function sum(a, b) {
  let args = [...arguments];
  console.log(args.reduce((sum, cur) => sum + cur));
}
sum(1, 2);    // 3
function sum(...args) {
  console.log(args.reduce((sum, cur) => sum + cur));
}
sum(1, 2);    // 3

// 可以看到，Array.from 和 ES6 的展开运算符，都可以把 arguments 这个类数组转换成数组 args，从而实现调用 reduce 方法对参数进行累加操作。其中第二种和第三种都是用 ES6 的展开运算符，虽然写法不一样，但是基本都可以满足多个参数实现累加的效果。
```



#### 数组扁平化

所谓扁平化，其实就是将一个嵌套多层的数组 array（嵌套可以是任何层数）转换为只有一层的数组。简单来说就是把多维的数组“拍平”，输出最后的一维数组。

> 方法一：ES6 的 flat 方法

```
const arr = [1,[1,2],[1,[3]]]console.log(arr.flat(Infinity))
```

这是数组自带的扁平化方法，flat的参数是说明需要展开几层，如果是Infinity无穷大的话，就是不管嵌套了几层，全部都会被展开 。想必这是大家一开始就想到的方法，毕竟那么好用的方法谁会不喜欢，但是如果你只知道这个的话，那不开心的肯定是面试官了。

> 方法二：递归

**递归**，用官方的话讲就是：在数学和计算机科学中，是指在函数的定义中使用函数本身的方法。通俗的话讲就是 *自己调用自己*。

```js
const arr = [1, [2, [3, [4, 5]]], 6];
const array = [];
const fn = (arr) => {
  for (let i = 0; i < arr.length; i++) {
    if (Array.isArray(arr[i])) {
      fn(arr[i]);
    } else {
      array.push(arr[i]);
    }
  }
};
fn(arr);
console.log(array);
```

最早接触使用扁平化递归的时候还是在刷蓝桥杯的题目，这应该也是面试中大家会写出来的方法，一整个全文背诵！

> 方法三：使用正则

```js
const arr = [1,[1,2],[1,[3]]]；
const res = JSON.stringify(arr).replace(/[|]/g, "");
const res2 = JSON.parse("[" + res + "]");
console.log(res2);
```

使用正则是我当时躺在床上想着有没有那种很难想到却很容易实现的方法，而正则是其实是我一直比较容易忘记的点，就那天却刚好想到这个点子：

- 首先是使用 JSON.stringify 把 arr 转为字符串
- 接着使用正则把字符串里面的 [ 和 ] 去掉
- 然后再拼接数组括号转为数组对象

> 方法四：使用 reduce

```js
const arr = [1,[1,2],[1,[3]]]；
const newArr = (arr) => {
  return arr.reduce((pre, cur) => {
    return pre.concat(Array.isArray(cur) ? newArr(cur) : cur);
  }, []);
};
console.log(newArr(arr), "reduce方法");
```

**reduce** 想必都是大家很喜欢的一个数组api，因为它相比于其他api，可玩性真的好很多。这里也用reduce来实现一下数组扁平化，其中也使用了 **concat**用于连接两个或多个数组，且该方法不会更改现有数组，而是返回一个新数组，其中包含已连接数组的值。

> 方法五：使用栈的思想实现 flat 函数

**栈（stack）** ，官方解释：又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。

```js
function flat(arr) {
  const newArr = [];
  const stack = [].concat(arr); 
  while (stack.length !== 0) {
    const val = stack.pop();
    if (Array.isArray(val)) {
      stack.push(...val);
    } else {
      newArr.unshift(val);
    }
  }
  return newArr;
}

let arr = [1,[1,2],[1,[3]]]；
console.log(flat(arr));
```

感觉用递归实现的需求用栈也能实现，就像树的三种遍历方式一样。实现的流程：

- 将数组元素拷贝至栈，直接赋值会改变原数组
- 如果栈不为空，则循环遍历
- 删除数组最后一个元素，并获取它
- 如果是数组再次入栈，并且展开了一层
- 如果不是数组就将其取出来放入结果数组中

#### 数组去重

去除无序数组中的重复元素并且返回新的无重复数组。

```js
# （1）Set实现
// ES6方法（使用数据结构集合）：

const array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];
Array.from(new Set(array)); // [1, 2, 3, 5, 9, 8]

# （2）map实现
// ES5方法：使用map存储不重复的数字

const array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];

function uniqueArray(array) {
  let map = {};
  let res = [];
  for(var i = 0; i < array.length; i++) {
    if(!map.hasOwnProperty([array[i]])) {
      map[array[i]] = 1;
      res.push(array[i]);
    }
  }
  return res;
}

uniqueArray(array); // [1, 2, 3, 5, 9, 8]
```

####  数组求和

```js
# （1）reduce实现
let arr = [1, 2, 3, 4, 5, 6]
let sum = arr.reduce( (total,i) => total += i,0);
console.log(sum);     // 21

#（2）递归实现
let arr = [1, 2, 3, 4, 5, 6] 
function add(arr) {
    if (arr.length == 1) return arr[0] 
    return arr[0] + add(arr.slice(1)) 
}
console.log(add(arr))  // 21
```

#### 数组乱序

**（1）正向遍历**

主要的实现思路就是：

1. 取出数组的第一个元素，随机产生一个索引值，将该第一个元素和这个索引对应的元素进行交换；
2. 第二次取出数据数组第二个元素，随机产生一个除了索引为1的之外的索引值，并将第二个元素与该索引值对应的元素进行交换；
3. 按照上面的规律执行，直到遍历完成。

```js
const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
for (var i = 0; i < arr.length; i++) {
  const randomIndex = Math.round(Math.random() * (arr.length - 1 - i)) + i;
  [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]];
}
console.log(arr)
```

**（2）倒序遍历**

倒序遍历和上面实现思路类似，代码如下：

```js
const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
let length = arr.length,
    randomIndex,
    temp;
  while (length) {
    randomIndex = Math.floor(Math.random() * length--);
    temp = arr[length];
    arr[length] = arr[randomIndex];
    arr[randomIndex] = temp;
  }
console.log(arr)
```

#### 手写数组的排序和查找

```js
// 插入排序
function sort(arr) {//原地
 for (let i in arr) {//选一个元素
  while (i>0&&arr[i]<arr[i-1]) {//向前移动到合适的位置
   [arr[i],arr[i-1]]=[arr[i-1],arr[i]]
   i--
  }
 }
}
```

```js
// 归并排序
function sort(arr) {
 if (arr.length===1) return arr

 //分成两部分
 let mid=Math.floor(arr.length/2)
 let [part1,part2]=[sort(arr.slice(0,mid)),sort(arr.slice(mid))]

 //对比+合并
 let result=[]
 while (part1.length>0&&part2.length>0)
  result.push((part1[0]<part2[0]?part1:part2).shift())
 return [...result,...part1,...part2]
}
```

```js
// 快速排序
function sort(arr) {
 if (arr.length<=1) return arr

    //选基准值
 let mid_pos=arr.length>>1
 let mid=arr.splice(mid_pos,1)[0]

 let left=[],right=[]

    //和基准值比较,分别插入left,right数组
 arr.forEach(item=>(item<=mid?left:right).push(item))

 return [...sort(left),mid,...sort(right)]//递归调用排序
}
```

```js
// 二分查找
function search(arr,target) {//循环写法,不断移动左右指针,缩小范围
 let left=0,right=arr.length-1

 while (left<=right) {
  const mid_pos=Math.floor((left+right)/2)
  const mid_val=arr[mid_pos]

  if (target===mid_val) {
   return mid_pos
  } else if (target>mid_val) {
   left=mid_pos+1
  } else {
   right=mid_pos-1
  }
 }
 return -1
}
```

```js
// 找出出现次数最多的元素 - getMostItem()
function getMost(arr) {
 //计数
 let map=new Map()
 arr.forEach(item=>{
  if (map.has(item)) {
   map.set(item,map.get(item)+1)
  } else {
   map.set(item,1)
  }
 })

 //找出出现最多
 let [max_vals,max_num]=[[arr[0]],map.get(arr[0])]
 map.forEach((count,item)=>{
  if (count>max_num){
   max_vals=[item]
   max_num=count
  } else {
   max_vals.push(item)
  } 
 })
 return max_vals
}

console.log(getMost(['1', '2', '3', '3', '55', '3', '55', '55']))
```

####  数组塌陷

> 数组塌陷（Array Collapse 或 Array Shift）是指在JavaScript或其他编程语言中，当你在一个数组中执行删除操作，特别是通过修改原数组结构的方式（如使用 `splice()` 方法），删除某个元素后，该元素后面的所有元素会自动前移填补它腾出的位置，导致原本位于这些元素之后的所有索引值都向前减少了一个单位。
>
> 由于数组的长度也随之减小，但循环变量还在按照原始未删除元素的索引顺序递增，因此可能会错过某些应当处理的元素，这就出现了“塌陷”现象。

```js
// 例如，考虑以下JavaScript代码片段，意图是从数组中删除所有的4：

var arr = [1, 1, 2, 1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 6];
 
//先给数组排序
arr.sort(function (min, max) { return min - max });
console.log(arr);
 
//然后循环遍历数组
 
// 当前的单元 和 下一个单元 进行数据的比较判断 
// 最后一个单元 没有 下一个单元进行比较判断
// 所以循环到 倒数第二个单元 就可以了 
// 也就是 循环至 倒数第二个单元的索引下标就可以了
for (var i = 0; i < arr.length - 1; i++) {
 
    //判断两个单元的数值是否相等
    // arr[i]   是 当前索引下标对应的单元
    // arr[i+1] 是 下一个索引下标对应的单元
    if (arr[i] === arr[i + 1]) {
       // 如果 两个单元 存储的数据相同 删除 后一个单元的数据
       arr.splice(i + 1, 1);
    }
}
console.log(arr);
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1711196681800.png" alt="1711196681800" style="zoom:50%;" />

> ### 解决方法
>
> 正确的做法是避免在循环中直接修改循环变量所依赖的数组长度。有两种常见的解决方案来应对数组塌陷问题：

```js
# 倒序遍历：

 var arr = [1, 1, 2, 1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 6];
 
 arr.sort(function (min, max) { return min - max });
 //console.log(arr);
 
 for (var i = arr.length - 1; i >= 0; i--) { 
     if (arr[i] === arr[i+1]) {
      arr.splice(i+1, 1);
     }
 }
 console.log(arr); 
 
// 从数组的末尾开始往前遍历并删除元素，这样即使数组长度发生变化，也不会影响尚未遍历到的元素。
```

```js
# 更新循环变量：

 var arr = [1, 1, 2, 1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 6];

 arr.sort(function (min, max) { return min - max });
 //console.log(arr);

 for (var i = 0; i < arr.length - 1; i++) {

     if (arr[i] === arr[i + 1]) {
         arr.splice(i + 1, 1);

         //消除数组坍塌造成的影响
         i--;  
     }
 }
 console.log(arr); 

// 在删除元素后立即手动减小循环变量以抵消数组长度的减少。
```

#### 数组使用技巧

##### 移除数组假值

可以使用 `filter()` 结合 `Boolean` 来简化移除数组假值操作。假值指的是在条件判断中被视为 `false` 的值，例如 `null`、`undefined`、空字符串（`""` 或 `''`）、0、`NaN` 和 `false`。

传统写法：

```js
let arr = [12, null, 0, 'xyz', null, -25, NaN, '', undefined, 0.5, false];


let filterArray = arr.filter(value => {
    if(value) {
      return value
    };
}); 
// [12, 'xyz', -25, 0.5]
```

简化写法：

```js
let arr = [12, null, 0, 'xyz', null, -25, NaN, '', undefined, 0.5, false];

let filterArray = arr.filter(value => Boolean(value)); // [12, 'xyz', -25, 0.5]
```

更简化写法：

```js
let arr = [12, null, 0, 'xyz', null, -25, NaN, '', undefined, 0.5, false];

let filterArray = arr.filter(Boolean); // [12, 'xyz', -25, 0.5]
```

`Boolean` 是 JavaScript 的内置构造函数，通过传递一个值给它，可以将该值转换为布尔值。在这种情况下，`Boolean` 构造函数作为回调函数传递给 `filter()` 方法，因此会将每个数组元素转换为布尔值。只有转换结果为真值的元素才会保留在新数组中。

注意：这种方式会将 0 也过滤掉，如果不需要过滤 0，需要进行额外的判断。

##### 数组查找

当对数组进行查找时，`indexOf()`用于获取查找项的位置。如果未找到该项，则返回值为`-1`。在JavaScript中，0被视为`false`，而大于或小于0的数字被视为`true`。因此，需要这样来写：

传统写法：

```js
if(arr.indexOf(item) > -1) { 

}

if(arr.indexOf(item) === -1) {

}
```

简化写法：

```js
if(~arr.indexOf(item)) {

}

if(!~arr.indexOf(item)) {

}
```

位非（~）运算符对除了-1之外的任何值都返回一个"真"值。对其进行取反就是简单地使用`!~`即可。另外，也可以使用`includes()`函数：

```js
if(arr.includes(item)) {

}
```

### Object

#### 声明(创建)

```js
// 我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js 和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象创建方式
（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。

（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。

（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。

（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。

（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。

（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。
```

> 详细资料可以参考：《JavaScript 深入理解之对象创建》

```js
1、 创建对象

1.1  直接量创建对象
      var obj = {}
1.2  new创建对象
       var obj = new Object()
备注1：new后面跟随的是构建函数constructor
备注2：构建函数用以初始化一个新创建对象
备注3：原始类型都包含内置构建函数

1.3 Object.create()创建对象
      var  = Object.create()
2、对象属性的查询和设置
     var name = obj.name
     var age = obj['age']
     obj.name = '李三'
     obj['age'] = 17
3、删除属性
      delete obj.name
4、检测属性
     in、hasOwnPreperty、prepertyIsEnumerable
5、枚举属性
    是否可以遍历对象的属性。
    ECMAScript 5之前用for/in变量对象中所有可枚举的属性。
    for(o in obj){  }
    ECMAScript 5之后Object.keys()遍历所有可枚举属性的名称；
    Object.getOwnPropertyNames()遍历对象所有自有属性的名称，包含不可枚举的。
6、属性的getter和setter
    ECMAScript 5中，属性值可以用一个或者两个方法代替，及getter和setter，
    被称之为存储器属性。
7、属性的特性
     对象属性包含名称、值、特性
     数据属性的4个特性：值、可写性、可枚举性和可配置性
         value、Writable、enumerable、configurable
         configurable：
            设置为false时：
              不可以通过delete删除，
              不可改为访问器属性
              描述符的其他属性不可被更改
        enumerable：设置为true时，表示可以通过for-in循环获取到返回值。默认值：false
        writable：设置为true时，表示属性的值是可以被修改。默认值：false
        value：属性的实际值。默认值：undefined
        上面所说的默认值都是通过Object.defineProperty去描述一个对象的属性，且第三个参数为一个空对象时默认值为false。如果通过字面量的方式定义对象的属性，对应的值都是true。
     存储器属性的4个特性：读取、写入、可枚举性和可配置性
		 get、set、enumerable、configurable
7.1 获取对象所有自有属性的描述符
       Object.getOwnPropertyDescriptors(obj)
7.2 获取对象自有属性名称为name的描述符
       Object.getOwnPropertyDescriptors(obj,'name')
7.3 修改或创建一个对象属性的描述符
	   Object.defineProperty(obj,'name',{ })
7.4 修改或创建多个对象属性的描述符
	   Object.defineProperties(obj,{
            'age' : {  },
            'tel': { }
        })
8、对象的三个属性
8.1 原型属性
8.1.1  查询对象的原型
    Object.getPrototypeOf(obj)
8.1.2 检测一个对象是否是另一个对象的原型（或处于原型链中）
    var obj = {
        name:'yanessa',
    }
    var newObj = Object.create(obj)
    console.log(obj.isPrototypeOf(newObj))
8.2 类属性

8.3 可扩展性
8.3.1 判断对象是否可扩展
	Object.isExtensible(obj)
8.3.2 将对象转化为不可扩展
	Object.preventExtensions(obj)
8.3.3 不可扩展的对象扩展后报错
	TypeError: Cannot define property name, object is not extensible
8.3.4  判断对象是否封闭
	Object.isSealed(obj) //已经封闭
8.3.5  将对象的所有自有属性都设置为不可配置
	Object.seal(obj)  
8.3.6  封闭后的对象
8.3.6.1 增加新的属性会报错
	TypeError: Cannot define property age, object is not extensible
8.3.6.2 删除已有属性返回false
	delete obj.name  
8.3.6.2 对于writable: false的对象属性重新配置会报错
	对于已有的可写属性依旧可以设置
	TypeError: Cannot redefine property: name
8.3.7  判断对象是否冻结
	Object.isFrozen(obj)
8.3.8  冻结对象
	不可扩展、不可配置、数据属性设置为只读、存储器属性具有setter方法不受  影响。
	Object.freeze(obj)
8.3.9 冻结后的对象修改报错
	TypeError: Cannot redefine property: name
9 、序列化对象

   对象序列化（serialization）是指将对象的状态转化为字符串JSON.stringify()，也可以将字符串转化为对象JSON.parse()
```

#### 方法

##### Object.keys()

> `Object.keys()` 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。

emmm... 并没有直接告诉我们输出顺序是什么，不过我们可以看看上面的 **Polyfill** 是怎么写的：

```js
if (!Object.keys) {
  Object.keys = (function () {
    var hasOwnProperty = Object.prototype.hasOwnProperty,
        hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),
        dontEnums = [
          'toString',
          'toLocaleString',
          'valueOf',
          'hasOwnProperty',
          'isPrototypeOf',
          'propertyIsEnumerable',
          'constructor'
        ],
        dontEnumsLength = dontEnums.length;

    return function (obj) {
      if (typeof obj !== 'object' && typeof obj !== 'function' || obj === null) throw new TypeError('Object.keys called on non-object');

      var result = [];

      for (var prop in obj) {
        if (hasOwnProperty.call(obj, prop)) result.push(prop);
      }

      if (hasDontEnumBug) {
        for (var i=0; i < dontEnumsLength; i++) {
          if (hasOwnProperty.call(obj, dontEnums[i])) result.push(dontEnums[i]);
        }
      }
      return result;
    }
  })()
};
```

其实就是利用 `for...in` 来进行遍历，接下来我们可以再看看关于 **for...in** 的文档，然而里面也没有告诉我们顺序是怎样的。

既然 MDN 上没有，那我们可以直接看 ECMAScript 规范，通常 MDN 上都会附上关于这个 API 的规范链接，我们直接点开最新（Living Standard）的那个，下面是关于 Object.keys 的**规范定义**：

> When the keys function is called with argument *O*, the following steps are taken:
>
> 1. Let *obj* be ? **ToObject**[10](*O*).
> 2. Let *nameList* be ? **EnumerableOwnPropertyNames**[11](*obj*, key).
> 3. Return **CreateArrayFromList**[12](*nameList*).

对象属性列表是通过 `EnumerableOwnPropertyNames` 获取的，这是它的**规范定义**：

> The abstract operation EnumerableOwnPropertyNames takes arguments O (an Object) and kind (key, value, or key+value). It performs the following steps when called:
>
> 1. Let ownKeys be ? O.[OwnPropertyKeys].
>
> 2. Let properties be a new empty List.
>
> 3. For each element key of ownKeys, do a. If Type(key) is String, then
>
>    b. Else, 1. Let value be ? Get(O, key). 2. If kind is value, append value to properties. 3. Else i. Assert: kind is key+value. ii. Let entry be ! CreateArrayFromList(« key, value »). iii. Append entry to properties.
>
> 4. 1. Let desc be ? O.GetOwnProperty.
>    2. If desc is not undefined and desc.[[Enumerable]] is true, then a. If kind is key, append key to properties.
>
> 5. Return properties.

敲黑板！这里有个细节，请同学们多留意，后面会考。

我们接着探索，`OwnPropertyKeys` 最终返回的 `OrdinaryOwnPropertyKeys`：

> The [[OwnPropertyKeys]] internal method of an ordinary object O takes no arguments. It performs the following steps when called:
>
> 1. Return ! **OrdinaryOwnPropertyKeys(O)**[13].

重头戏来了，关于 keys 如何排序就在 `OrdinaryOwnPropertyKeys` 的定义中：

> The abstract operation OrdinaryOwnPropertyKeys takes argument O (an Object). It performs the following steps when called:
>
> 1. Let keys be a new empty List.
> 2. For each own property key P of O such that P is an array index, in ascending numeric index order, do a. Add P as the last element of keys.
> 3. For each own property key P of O such that Type(P) is String and P is not an array index, in ascending chronological order of property creation, do a. Add P as the last element of keys.
> 4. For each own property key P of O such that Type(P) is Symbol, in ascending chronological order of property creation, do a. Add P as the last element of keys.
> 5. Return keys.

到这里，我们已经知道我们想要的答案，这里总结一下：

1. 创建一个空的列表用于存放 keys
2. 将所有**合法的数组索引**按升序的顺序存入
3. 将所有**字符串类型索引**按属性创建时间以升序的顺序存入
4. 将所有 **Symbol 类型索引**按属性创建时间以升序的顺序存入
5. 返回 keys

这里顺便也纠正一个普遍的误区：有些回答说将所有属性为数字类型的 key 从小到大排序，其实不然，还必须要符合 **「合法的数组索引」** ，也即只有**正整数**才行，负数或者浮点数，一律当做字符串处理。

PS：严格来说对象属性没有数字类型的，无论是数字还是字符串，都会被当做字符串来处理。

我们结合上面的规范，来思考一下下面这段代码会输出什么：

```js
const testObj = {}

testObj[-1] = ''
testObj[1] = ''
testObj[1.1] = ''
testObj['2'] = ''
testObj['c'] = ''
testObj['b'] = ''
testObj['a'] = ''
testObj[Symbol(1)] = ''
testObj[Symbol('a')] = ''
testObj[Symbol('b')] = ''
testObj['d'] = ''

console.log(Object.keys(testObj))
```

请认真思考后，在这里核对你的答案是否正确：

查看结果 

```
['1', '2', '-1', '1.1', 'c', 'b', 'a', 'd']
```

是否与你想象的一致？你可能会奇怪为什么没有 `Symbol` 类型。

还记得前面敲黑板让同学们留意的地方吗，因为在 `EnumerableOwnPropertyNames` 的规范中规定了返回值只应包含字符串属性（上面说了数字其实也是字符串）。

所以 Symbol 属性是不会被返回的，可以看 **MDN** 上关于 `Object.getOwnPropertyNames()` 的描述。

如果要返回 Symbol 属性可以用 **Object.getOwnPropertySymbols()**。

##### ES6 新增对象属性和方法

###### **Object.assign**

> `Object.assign` 是一个ES6新增的方法，用于将一个或多个源对象的属性复制到目标对象中。

```js
# Object.assign(target, ...sources)

参数：

• 目标对象（target）：合并其他对象到该目标对象中。
• 源对象（source1, source2, ...）：要合并到目标对象的一个或多个源对象。
• 属性：
• 返回值：Object.assign() 方法返回合并后的目标对象。

# 该方法会遍历所有源对象的可枚举属性，并将它们复制到目标对象中，如果属性名相同，则后面的源对象会覆盖前面的。

# Object.assign 方法并不会复制继承自原型链上的属性，也不会复制不可枚举的属性，只会复制对象自身的可枚举属性。此外，如果源对象的属性值是一个引用类型的值（如数组或对象），那么目标对象得到的属性值也是这个引用类型的值，而不是它的副本。

# 需要注意的是，Object.assign() 方法会修改目标对象 target，并返回合并后的目标对象。如果目标对象和源对象有相同的属性，后续的源对象的属性值将覆盖前面源对象的属性值。
```

```js
const target = { a: 1, b: 2 };
const source1 = { b: 3, c: 4 };
const source2 = { d: 5 };

const result = Object.assign(target, source1, source2);

console.log(target); // { a: 1, b: 3, c: 4, d: 5 }
console.log(result); // { a: 1, b: 3, c: 4, d: 5 }
```

```js
# 需要注意的是，Object.assign 方法并不会创建新对象，而是直接修改目标对象。如果需要创建一个新的对象来保存合并后的属性，可以将空对象作为目标对象传递给 Object.assign 方法：
const target = { a: 1 };
const source = { b: 2 };

const result = Object.assign({}, target, source);

console.log(target); // { a: 1 }
console.log(source); // { b: 2 }
console.log(result); // { a: 1, b: 2 }

# Object.assign 方法不会修改原有的 target 和 source 对象。
```

###### **Object.getOwnPropertyDescriptors()**

> 可以获取一个对象所有属性的描述符。

```js
const obj = {
  name: 'John',
  age: 30
};

const descriptors = Object.getOwnPropertyDescriptors(obj);
console.log(descriptors);
/*
{
  name: { value: 'John', writable: true, enumerable: true, configurable: true },
  age: { value: 30, writable: true, enumerable: true, configurable: true }
}
*/
```

###### **Object.setPrototypeOf()**

> 可以设置一个对象的原型。

```js
const obj1 = { a: 1 };
const obj2 = { b: 2 };

Object.setPrototypeOf(obj1, obj2);
console.log(obj1.b); // 2
```

###### **Object.entries()**

```js
const obj = { a: 1, b: 2, c: 3 };
const map = Object.entries(obj).reduce((acc, [key, value]) => {
  acc.set(key, value);
  return acc;
}, new Map());
console.log(map); // Map(3) { 'a' => 1, 'b' => 2, 'c' => 3 }
```

#### 继承

```
（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。

（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。

（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。

（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。

（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。

（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。
```

> 详细资料可以参考：《JavaScript 深入理解之继承》

```js
// 寄生式组合继承的实现
function Person(name) {
  this.name = name;
}

Person.prototype.sayName = function() {
  console.log("My name is " + this.name + ".");
};

function Student(name, grade) {
  Person.call(this, name);
  this.grade = grade;
}

Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;

Student.prototype.sayMyGrade = function() {
  console.log("My grade is " + this.grade + ".");
  
};
```

###### 原型链继承

直接利用原型链特征实现的继承，让构造函数的`prototype`指向另一个构造函数的实例。

```js
function Person() {
  this.head = 1
  this.hand = 2
}

function YellowRace() { }
YellowRace.prototype = new Person()

const hjy = new YellowRace()

console.log(hjy.head) // 1
console.log(hjy.hand) // 2
```

上述代码中的`Person构造函数`、`YellowRace构造函数`、`hjy实例`之间的关系如下图：

![1714198400845](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1714198400845.png)

根据原型链的特性，当我们查找`hjy`实例的`head`和`hand`属性时，由于`hjy`本身并没有这两个属性，引擎就会去查找`hjy`的原型，还是没有，继续查找`hjy`原型的原型，也就是`Person原型对象`，结果就找到了。就这样，`YellowRace`和`Person`之间通过原型链实现了继承关系。

但这种继承是有问题的：

1. 创建`hjy`实例时不能传参，也就是`YellowRace`构造函数本身不接受参数。
2. 当原型上的属性是引用数据类型时，所有实例都会共享这个属性，即某个实例对这个属性重写会影响其他实例。

针对第二点，我们通过一段代码来看一下：

```js
function Person() {
  this.colors = ['white', 'yellow', 'black']
}

function YellowRace() { }
YellowRace.prototype = new Person()

const hjy = new YellowRace()
hjy.colors.push('green')
 console.log(hjy.colors) // ['white', 'yellow', 'black', 'green']

const laowang = new YellowRace()
console.log(laowang.colors) // ['white', 'yellow', 'black', 'green']
```

可以看到，`hjy`只是想给自己的生活增添一点绿色，但是却被`laowang`给享受到了，这肯定不是我们想看到的结果。

为了解决不能传参以及引用类型属性共享的问题，一种叫**盗用构造函数**的实现继承的技术应运而生。

###### 盗用构造函数

盗用构造函数也叫作“对象伪装”或者“经典继承”，原理就是通过在子类中调用父类构造函数实现上下文的绑定。

```js
function Person(eyes) {
  this.eyes = eyes
  this.colors = ['white', 'yellow', 'black']
}

function YellowRace() {
  Person.call(this, 'black') // 调用构造函数并传参
}

const hjy = new YellowRace()
hjy.colors.push('green')
console.log(hjy.colors) // ['white', 'yellow', 'black', 'green']
console.log(hjy.eyes) // black

const laowang = new YellowRace()
console.log(laowang.colors) // ['white', 'yellow', 'black']
console.log(laowang.eyes) // black
```

上述代码中，`YellowRace`在内部使用`call`调用构造函数，这样在创建`YellowRace`的实例时，`Person`就会在`YellowRace`实例的上下文中执行，于是每个`YellowRace`实例都会拥有自己的`colors`属性，而且这个过程是可以传递参数的，`Person.call()`接受的参数最终会赋给`YellowRace`的实例。它们之间的关系如下图所示：

![1714198469468](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1714198469468.png)

虽然盗用构造函数解决了原型链继承的两大问题，但是它也有自己的缺点：

1. 必须在构造函数中定义方法，通过盗用构造函数继承的方法本质上都变成了实例自己的方法，不是公共的方法，因此失去了复用性。
2. 子类不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式，原因如上图所示，`YellowRace`构造函数、`hjy`和`laowang`实例都没有和`Person`的原型对象产生联系。

针对第二点，我们看一段代码：

```js
function Person(eyes) {
  this.eyes = eyes
  this.getEyes = function () {
    return this.eyes
  }
}

Person.prototype.ReturnEyes = function () {
  return this.eyes
}

function YellowRace() {
  Person.call(this, 'black')
}

const hjy = new YellowRace()
console.log(hjy.getEyes()) // black
console.log(hjy.ReturnEyes()) // TypeError: hjy.ReturnEyes is not a function
```

可以看到，`hjy`实例能继承`Person`构造函数内部的方法`getEyes()`，对于`Person`原型对象上的方法，`hjy`是访问不到的。

###### 组合继承

原型链继承和盗用构造函数继承都有各自的缺点，而组合继承综合了前两者的优点，取其精华去其糟粕，得到一种可以将方法定义在原型上以实现重用又可以让每个实例拥有自己的属性的继承方案。

组合继承的原理就是先通过盗用构造函数实现上下文绑定和传参，然后再使用原型链继承的手段将子构造函数的`prototype`指向父构造函数的实例，代码如下：

```js
function Person(eyes) {
  this.eyes = eyes
  this.colors = ['white', 'yellow', 'black']
}

Person.prototype.getEyes = function () {
  return this.eyes
}

function YellowRace() {
  Person.call(this, 'black') // 调用构造函数并传参
}
YellowRace.prototype = new Person() // 再次调用构造函数

const hjy = new YellowRace()
hjy.colors.push('green')

const laowang = new YellowRace()

console.log(hjy.colors) // ['white', 'yellow', 'black', 'green']
console.log(laowang.colors) // ['white', 'yellow', 'black']
console.log(hjy.getEyes()) // black
```

`hjy`终于松了口气，自己终于能独享生活的一点“绿”，再也不会被老王分享去了。

此时`Person`构造函数、`YellowRace`构造函数、`hjy`和`laowang`实例之间的关系如下图：

![1714198516021](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1714198516021.png)

相较于盗用构造函数继承，组合继承额外的将`YellowRace`的原型对象（同时也是`hjy`和`laowang`实例的原型）指向了`Person`的原型对象，这样就集合了原型链继承和盗用构造函数继承的优点。

但组合继承还是有一个小小的缺点，那就是在实现的过程中调用了两次`Person`构造函数，有一定程度上的性能浪费。这个缺点在最后的寄生式组合继承可以改善。

###### 原型式继承

> 2006年，道格拉斯.克罗克福德写了一篇文章《Javascript中的原型式继承》。这片文章介绍了一种不涉及严格意义上构造函数的继承方法。他的出发点是即使不自定义类型也可以通过原型实现对象之间的信息共享。

文章最终给出了一个函数：

```js
const object = function (o) {
  function F() { }
  F.prototype = o
  return new F()
}
```

其实不难看出，这个函数将原型链继承的核心代码封装成了一个函数，但这个函数有了不同的适用场景：如果你有一个已知的对象，想在它的基础上再创建一个新对象，那么你只需要把已知对象传给`object`函数即可。

```js
const object = function (o) {
  function F() { }
  F.prototype = o
  return new F()
}

const hjy = {
  eyes: 'black',
  colors: ['white', 'yellow', 'black']
}

const laowang = object(hjy)
console.log(laowang.eyes) // black
console.log(laowang.colors) // ['white', 'yellow', 'black']
```

`ES5`新增了一个方法`Object.create()`将原型式继承规范化了。相比于上述的`object()`方法，`Object.create()`可以接受两个参数，第一个参数是作为新对象原型的对象，第二个参数也是个对象，里面放入需要给新对象增加的属性（可选）。

第二个参数与`Object.defineProperties()`方法的第二个参数是一样的，每个新增的属性都通过自己的属性描述符来描述，以这种方式添加的属性会遮蔽原型上的同名属性。当`Object.create()`只传入第一个参数时，功效与上述的`object()`方法是相同的。

```js
const hjy = {
  eyes: 'black',
  colors: ['white', 'yellow', 'black']
}

const laowang = Object.create(hjy, {
  name: {
    value: '老王',
    writable: false,
    enumerable: true,
    configurable: true
  },
  age: {
    value: '32',
    writable: true,
    enumerable: true,
    configurable: false
  }
})
console.log(laowang.eyes) // black
console.log(laowang.colors) // ['white', 'yellow', 'black']
console.log(laowang.name) // 老王
console.log(laowang.age) // 32
```

稍微需要注意的是，`object.create()`通过第二个参数新增的属性是直接挂载到新建对象本身，而不是挂载在它的原型上。*原型式继承非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。*

上述代码中各个对象之间的关系仍然可以用一张图展示：

![1714198632445](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1714198632445.png)

这种关系和原型链继承中原型与实例之间的关系基本是一致的，不过上图中的`F`构造函数是一个中间函数，在`object.create()`执行完后它就随着函数作用域一起被回收了。那最后`hjy`的`constructor`会指向何处呢？下面分别是浏览器和`node`环境下的打印结果：

![1714198659011](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1714198659011.png)

![1714198669327](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1714198669327.png)

查阅资料得知`chrome`打印的结果是它内置的，不是`javascript`语言标准。具体是个啥玩意儿我也不知道了🤣。

既然原型式继承和原型链继承的本质基本一致，那么原型式继承也有一样的缺点：

1. 不能传参，使用手写的`object()`不能传，但使用`Object.create()`是可以传参的。
2. 原对象中的引用类型的属性会被新对象共享。

###### 寄生式继承

寄生式继承与原型式继承很接近，它的思想就是在原型式继承的基础上以某种方式增强对象，然后返回这个对象。

```js
function inherit(o) {
  let clone = Object.create(o)
  clone.sayHi = function () { // 增强对象
    console.log('Hi')
  }
  return clone
}

const hjy = {
  eyes: 'black',
  colors: ['white', 'yellow', 'black']
}

const laowang = inherit(hjy)

console.log(laowang.eyes) // black
console.log(laowang.colors) // ['white', 'yellow', 'black']
laowang.sayHi() // Hi
```

这是一个最简单的寄生式继承案例，这个例子基于`hjy`对象返回了一个新的对象`laowang`，`laowang`拥有`hjy`的所有属性和方法，还有一个新方法`sayHai()`。

可能有的小伙伴就会问了，寄生式继承就只是比原型式继承多挂载一个方法吗？这也太`low`了吧。其实没那么简单，这里只是演示一下挂载一个新的方法来增强新对象，但我们还可以用别的方法呀，比如改变原型的`constructor`指向，在下面的寄生式组合继承中就会用到。

###### 寄生式组合继承

寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方法。基本思路就是使用寄生式继承来继承父类的原型对象，然后将返回的新对象赋值给子类的原型对象。

首先实现寄生式继承的核心逻辑：

```js
function inherit(Son, Father) {
  const prototype = Object.create(Father.prototype) // 获取父类原型对象副本
  prototype.constructor = Son // 将获取的副本的constructor指向子类，以此增强副本原型对象
  Son.prototype = prototype // 将子类的原型对象指向副本原型对象
}
```

这里没有将新建的对象返回出来，而是赋值给了子类的原型对象。

接下来就是改造组合式继承，将第二次调用构造函数的逻辑替换为寄生式继承：

```js
function Person(eyes) {
  this.eyes = eyes
  this.colors = ['white', 'yellow', 'black']
}

Person.prototype.getEyes = function () {
  return this.eyes
}

function YellowRace() {
  Person.call(this, 'black') // 调用构造函数并传参
}

inherit(YellowRace, Person) // 寄生式继承，不用第二次调用构造函数

const hjy = new YellowRace()
hjy.colors.push('green')

const laowang = new YellowRace()

console.log(hjy.colors) // ['white', 'yellow', 'black', 'green']
console.log(laowang.colors) // ['white', 'yellow', 'black']
console.log(hjy.getEyes()) // black
```

上述寄生式组合继承只调用了一次`Person`造函数，避免了在`Person.prototype`上面创建不必要、多余的属性。于此同时，原型链依然保持不变，效率非常之高效。

如图，寄生组合式继承与组合式继承中的原型链关系是一样的：

![1714198748742](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1714198748742.png)

#### 原型，原型链

```
在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对 象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部 将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说我们 是不应该能够获取到这个值的，但是现在浏览器中都实现了 proto 属性来让我们访问这个属性，但是我们最好不要使用这 个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，我们可以通过这个方法来获取对 象的原型。

当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又 会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就 是我们新建的对象为什么能够使用 toString() 等方法的原因。

特点：

JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与 之相关的对象也会继承这一改变。
```

> 所有普通的`[[Prototype]]`都会指向内置的`Object.prototype`，而`Object`的`[[Prototype]]`指向`null`。也就是说所有的普通对象都源于`Object.prototype`，它包含`javascript`中许多通用的功能。
>
> ![1714198203566](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1714198203566.png)

> 《JavaScript 深入理解之原型与原型链》
>
> 「前端料包」深入理解JavaScript原型和原型链

##### 获取原型的方法

```js
p.proto
p.constructor.prototype
Object.getPrototypeOf(p)
```

#### 对象不变性

> 对象不变性在任何编程语言中都是一个重要的概念。它会限制对象修改并防止不需要的更改。简而言之，对象的不变性就是将它的状态变为只读的，下面就来看看在 JavaScript 中的对象不变性。
>
> 在JavaScript中，一个对象可以有一个或多个属性。每个属性都是一个键值对，下面是一个对象：
>
> ```js
> const user = {
>  name: 'CUGGZ',
>   age: 24,
> }
> ```
>
> 这里使用const关键字定义了一个对象，它具有两个属性。默认情况下，对象是可变的，也就是说，我们可以给对象添加新属性，修改现有属性或者删除已有属性。而在某些情况下，我们可能希望对象是不可变的，即不能添加新属性，也不能修改和删除已有属性。
>
> 下面就来看看，JavaScript中有哪些实现不变性的方法。

```js
# Object.freeze()

// 顾名思义，freeze() 就是用来冻结对象的。只需要将不想被更改的对象传递给它，就会返回该对象的不可变版本：

const user = {
 name: 'CUGGZ',
  age: 24,
}

const freezeUser = Object.freeze(user);
freezeUser.age = 18;
console.log(freezeUser.age) // 24

// 这时，新的对象就不可变了，相当于被冻结了。

// 在JavaScript了，提供了一个Object.isFrozen()，它可以用来判断一个对象是否被冻结：

Object.isFrozen(user)  // false
Object.isFrozen(freezeUser)  // true

# 需要注意的是， Object.freeze() 方法不会影响嵌套对象，对于嵌套对象，冻结后仍然是可以操作的：

const user = {
 name: 'CUGGZ',
  age: 24,
  article: {
   title: 'learn javascript',
    number: 1234
  }
}

const freezeUser = Object.freeze(user);
freezeUser.age = 18
freezeUser.article.number = 666;
console.log(freezeUser.age)             // 24
console.log(freezeUser.article.number); // 666

// 可以看到，使用 Object.freeze() 方法冻结的对象，age是不可以更改的，但是嵌套对象的number属性还是可以修改的。如果需要冻结嵌套对象使其不可变，就需要使用循递归来逐级冻结，下面是一个简单的递归冻结实现：

const deepFreeze = obj => {
  Object.keys(obj).forEach(prop => {
    if (typeof obj[prop] === 'object') {
     deepFreeze(obj[prop]);
    }
  });
  return Object.freeze(obj);
};

deepFreeze(user);

# Object.freeze()方法除了可以用来冻结对象以外，还可以用于冻结数组，使其不可变：

const number = [1, 2, 3, 4, 5];
const freezeNumber = Object.freeze(number);
freezeNumber.push(6);

#此时就会报错了：

VM210:3 Uncaught TypeError: Cannot add property 5, object is not extensible
```

```js
#  Object.seal()

// Object.seal() 顾名思义就是密封对象，它是另一种使对象不可变的方法。相对于freeze()，Object.seal() 方法仅保护对象不能添加和删除属性，它允许更新现有的属性。

const user = {
 name: 'CUGGZ',
  age: 24,
}

const sealUser = Object.seal(user);
sealUser.age = 18;
delete sealUser.name;
console.log(sealUser)   // {name: 'CUGGZ', age: 18}

// 可以看到，我们识图删除对象中的name属性，删除失败；而修改已有的age属性，修改成功。

// Object.seal()方法和Object.freeze()一样，对于嵌套的对象，是无法实现不可变的，如果想要实现，同样要使用递归来一层层来密封对象。

// JavaScript同样提供了一个Object.isSealed() 方法来确认对象的密封状态：

Object.isSealed(user)      // false
Object.isSealed(sealUser)  // true
```

```js
# const关键字？

// 你是否会认为，使用const关键字也能达到相同的结果呢？实际上，他们是不一样的，当我们使用const关键字来创建对象时，它会阻止我们重新分配值，但是我们可以更新、添加、删除已有对象的属性：

const user = {
 name: 'CUGGZ',
  age: 24,
}

delete user.age;
user.height = 180;
user.name = 'hello';
console.log(user);  // {name: 'hello', height: 180}

// 而如果我们给user重新赋值，那么就会报错了：

Uncaught TypeError: Assignment to constant variable.

# 因此，const关键字仅仅是提供了赋值的不变性，而不会提供值的不变性（对于对象来说）。
```

> ##  总结
>
> 本文简单介绍了两种可以用于使JavaScript不可变的方法。简而言之，Object.freeze()方法会阻止更新、删除和向对象添加新属性，Object.seal()只会阻止添加和删除属性。
>
> 除此之外，JavaScript还提供了一个Object.preventExtensions()方法，该方法可以让一个对象变的不可扩展，也就是永远不能再添加新的属性。
>
> ```js
> const user = {
>  name: 'CUGGZ',
>   age: 24,
> }
> 
> const newUser = Object.preventExtensions(user);
> newUser.height = 180;
> console.log(newUser);  //  {name: 'CUGGZ', age: 24}
> ```
>
> 最后来看看它们三个的对比：
>
> ![1712379136243](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1712379136243.png)

#### 对象使用技巧

##### 判断一个对象是否为空

> 判断一个对象是否为空时，使用 `Reflect.ownKeys` 方法最为完美。

```js
# 1. JSON.stringify
// JSON.stringify 方法可以使对象序列化，转为相应的 JSON 格式。

const obj = {};

console.log(JSON.stringify(obj) === '{}')  // true

# 缺点：如果存在 undefined、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时）。

// 如下示例：

const obj = {
  a: undefined,
  b: function() {},
  c: Symbol()
}

console.log(JSON.stringify(obj) === '{}')  // true
```

```js
# 2. for in 配合 hasOwnProperty
// 使用 for in 对当前对象进行遍历：

const obj = {}
Object.prototype.a = 1

function isEmptyObj(obj) {
  let flag = true
  for (let o in obj) {
    flag = false
    break
  }
  return flag
}

console.log(isEmptyObj(obj))  // false
# 由于 for in 在进行对象遍历时，会遍历对象原型上的属性，而我们只希望得到其自身的属性，这时可以使用 hasOwnProperty 来实现，如下：

const obj = {}
Object.prototype.a = 1

function isEmptyObj(obj) {
  let flag = true
  for (let o in obj) {
    if (obj.hasOwnProperty(o)) {
      flag = false
      break
    }
  }
  return flag
}

console.log(isEmptyObj(obj))  // true
# 缺点：for in 不能遍历不可枚举的属性。
```

```js
# 3. Object.keys
// Object.keys 会返回对象自身可枚举属性组成的数组，而不会遍历原型上的属性。

const obj = {}
Object.prototype.a = 1

console.log(Object.keys(obj).length === 0)  // true
# 缺点：Object.keys 和 for in 都只能遍历可枚举属性，不能遍历不可枚举的属性。

// 我们使用 Object.defineProperty 将属性 enumerable 设置为 false 来进行测试，示例如下：

const obj = {}
Object.defineProperty(obj, 'a', {
  value: 1,
  enumerable: false
})

console.log(obj.a)  // 1
console.log(isEmptyObj(obj))  // true
console.log(Object.keys(obj).length === 0)  // true
```

```js
# 4. Object.getOwnPropertyNames
// 使用 Object.getOwnPropertyNames 可以得到对象自身的所有属性名组成的数组(包括不可枚举属性)。

const obj = {}
Object.defineProperty(obj, 'a', {
  value: 1,
  enumerable: false
})

console.log(Object.getOwnPropertyNames(obj))  // [ 'a' ]
# 缺点：不能获取 Symbol 值作为名称的属性，以上的 JSON.stringify、for in 以及 Object.keys 方法也不能获取Symbol 值作为名称的属性，示例如下：

const a = Symbol()
const obj = {
  [a]: 1
}

console.log(obj)  // { [Symbol()]: 1 }
console.log(Object.getOwnPropertyNames(obj).length === 0)  // true
console.log(JSON.stringify(obj) === '{}')  // true
console.log(isEmptyObj(obj))  // true
console.log(Object.keys(obj).length === 0)  // true
```

```js
# 5. Object.getOwnPropertyNames 结合 Object.getOwnPropertySymbols
// 已知 Object.getOwnPropertyNames 唯一的缺点是不能获取 Symbol 值作为名称的属性，而 Object.getOwnPropertySymbols 只能获取由 Symbol 值作为名称的属性，两者相结合是不是就可以完美解决了。我们来简单测试一下：

const a = Symbol()
const obj1 = {
  [a]: 1
}
const obj2 = {b: 2}
const obj3 = {}
Object.defineProperty(obj3, 'a', {
  value: 1,
  enumerable: false
})
const obj4 = {}

function getLength(obj) {
  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj)).length
}

console.log(getLength(obj1) === 0)  // false
console.log(getLength(obj2) === 0)  // false
console.log(getLength(obj3) === 0)  // false
console.log(getLength(obj4) === 0)  // true
```

```js
# 6. Reflect.ownKeys
// Reflect.ownKeys 方法返回一个由目标对象自身的属性组成的数组，它的返回值等同于 Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))，示例如下：

const a = Symbol()
const obj1 = {
  [a]: 1
}
const obj2 = {b: 2}
const obj3 = {}
Object.defineProperty(obj3, 'a', {
  value: 1,
  enumerable: false
})
const obj4 = {}

console.log(Reflect.ownKeys(obj1).length === 0)  // false
console.log(Reflect.ownKeys(obj2).length === 0)  // false
console.log(Reflect.ownKeys(obj3).length === 0)  // false
console.log(Reflect.ownKeys(obj4).length === 0)  // true
```

##### 创建一个绝对空的对象

我们可以通过 `{}` 来创建空对象。 然而，通过方法中创建的对象，`proto`、`hasOwnProperty`等对象方法仍然是存在的，这是因为使用 `{}` 将创建一个继承自 `Object` 类的对象。

如果需要创建一个绝对空的对象，最好使用 `Object.create(null)`，它将创建一个不从任何对象继承且没有属性的对象。

```js
let vehical = Object.create(null);// vehicle.__proto__ === "undefined"  ✅
```

##### Object.create()和new Object()

Object.create()继承指定对象， new Object()继承内置对象Object

![1713685352257](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1713685352257.png)

Object.create()必须传入一个对象最为参数；

Object的prototype

![1713685363876](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1713685363876.png)

new Object创建一个Object对象实例

```js
var obj = new Object()
```

obj对象实例原型指向的是Object.prototype

![1713685393859](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1713685393859.png)

Object.create(null)创建一个干净的对象，也就是没有原型，而 `new Object()` 创建的对象是 Object的实例，原型永远指向`Object.prototype`

![1713685436867](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1713685436867.png)

```js
Object.create(Array.prototype)
```

![1713685466439](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1713685466439.png)

##### Object.prototype.hasOwnProperty.call(myObj, prop)

```js
var obj = new Object();

obj.ownProp1 = 'ownProp1';

console.log(obj.hasOwnProperty('ownProp1')); //true

console.log(({}).hasOwnProperty.call(obj,'ownProp1'));//true

console.log(Object.hasOwnProperty.call(obj,'ownProp1'));//true

console.log(Object.prototype.hasOwnProperty.call(obj,'ownProp1'));//true



# 为什么使用Object.prototype.hasOwnProperty.call(myObj, prop) 替换 myObj.hasOwnProperty(prop)?

# 1、如果obj从null继承而不是Object.prototype

# 2、如果在obj上重新声明了hasOwnProperty

# 3、如果在obj的原型链中重新声明了hasOwnProperty



1、如果obj从null继承而不是Object.prototype

var nullObj = Object.create(null);

nullObj.ownProp1 = 'ownProp1'

console.log(nullObj.hasOwnProperty('ownProp1'))  //TypeError: nullObj.hasOwnProperty is not a function



2、如果在obj上重新声明了hasOwnProperty

// 因为javascript没有将hasOwnProperty作为一个敏感词，

//所以我们很有可能将对象的一个属性命名为hasOwnProperty，

//这样一来就无法再使用对象原型的 hasOwnProperty 方法来判断属性是否是来自原型链。



var obj = new Object();

obj.ownProp1 = 'ownProp1';

obj.hasOwnProperty = function(name){

    return name;

}

console.log(obj.hasOwnProperty("ownProp1"))  //ownProp1

console.log(({}).hasOwnProperty.call(obj,'ownProp1')) //true

console.log(Object.hasOwnProperty.call(obj,'ownProp1')) //true



3、如果在obj的原型链中重新声明了hasOwnProperty

var obj = new Object();

var obj2 = Object.create(obj);

obj2.ownProp1 = 'ownProp1';

obj.hasOwnProperty = function(name){

    return name;

}

console.log(obj2.hasOwnProperty("ownProp1"))  //ownProp1

console.log(({}).hasOwnProperty.call(obj2,'ownProp1')) //true

console.log(Object.hasOwnProperty.call(obj2,'ownProp1')) //true
```

##### 使用扩展运算符组合两个对象

在许多情况下，需要组合来自不同来源的两个或多个数据集。

最常用的方法是使用 `Object.assign()`。该方法需要多个参数。 第一个是分配的对象，其余参数是需要组合的对象。

```js
const name = { id: '1234', name: 'Charuka'};
const university = { id: '1234', university: 'Harvard'};
const PersonalDetails = Object.assign({}, name, university);

console.log(PersonalDetails); 
// { id: '1234', name: 'Charuka', university: 'Harvard' }
```

使用扩展运算符进行组合更方便，只需展开任意数量的对象，并将它们组合成一个对象即可。

```js

const PersonalDetails = { ...name, ...university };

console.log(PersonalDetails); 
// { id: '1234', name: 'Charuka', university: 'Harvard' }
```

需要注意，如果存在重复的键，那后面的会将覆盖前面对象的键。

##### 检查属性

使用 for-in 循环时，检查对象的属性有助于避免迭代对象原型中的属性。可以使用 `Object.hasOwnProperty()`进行检查，而不是使用 if-else。

```js
const vehicle = { brand: 'BWM', year: 2022, type: 'suv'};
for (var item in vehicle) {  
    if (vehicle.hasOwnProperty(item)) { 
        console.log(item);                 
    };  
};
// brand
// year
// type
```

##### 克隆对象

假设有一个对象并且需要复制它以更改其值，但原始对象应该保持不变。可以通过以下方法来实现。

第一种方法是使用 `Object.assign()`，它将所有可枚举属性的值从一个对象复制到另一个对象。

```js
const initialVehicle = { brand: 'BWM', year: 2022, type: 'suv'};
const secondaryVehicle = Object.assign({}, initialVehicle);
console.log(secondaryVehicle); // { brand: 'BWM', year: 2022, type: 'suv'};
```

第二种方法是使用 `JSON.parse()` 复制对象。

```js
var initialVehicle = { brand: 'BWM', year: 2022, type: 'suv'};
var secondaryVehicle = JSON.parse(JSON.stringify(initialVehicle));
console.log(secondaryVehicle); // { brand: 'BWM', year: 2022, type: 'suv'};
```

##### 从对象中选择特定数据

针对对象中的特定键（`key`），可以使用不同的方法进行选择。选择方法的选择取决于希望对这些值进行的操作。下面的示例展示了一种有条理的方式从对象中选择数据，并可以选择所需的键，并将它们提取到一个新的对象中。

```JS
const selectObj = (obj, items) => { 
  return items.reduce((result, item) => {
    result[item] = obj[item]; 
    return result;
  }, {});
};
const vehicle = { brand: 'BWM', year: 2022, type: 'suv'};
const selected = selectObj(vehicle, ['brand', 'type']);
console.log(selected); // { brand: 'BWM', type: 'suv' }
```

##### 从对象中删除键

有时我们需要从对象中删除特定的键及其值。最合适的方法是编写一个可重用的删除方法，该方法将一个对象和要删除的键列表作为输入。 然后循环遍历要删除的每个键并将其从对象中删除。

```js
const remove = (object, removeList = []) => {
  const result = { ...object };
  removeList.forEach((item) => {
    delete result[item];
  });
  return result;
}

const vehicle = { brand: 'BWM', year: 2022, type: 'suv'}

const itemRemoved = remove(vehicle, ['year']);
console.log(itemRemoved); // Result { brand: 'BWM', type: 'suv' }
```

##### `Object.keys()` 是按照什么顺序返回值的

> - `Object.keys()` 返回顺序与遍历对象属性时的顺序一样，调用的 `[[OwnPropertyKeys]]()` 内部方法。
> - 根据 **ECMAScript 规范**，在输出 keys 时会**先将所有 key 为数组索引类型（正整数）从小到大的顺序排序，然后将所有字符串类型（包括负数、浮点数）的 key 按照实际创建的顺序来排序**。
>
> ```js
> const sorted = {}
> 
> sorted[300] = {}
> sorted[200] = {}
> sorted[100] = {}
> 
> console.log(Object.keys(sorted)) // 输出什么呢？
> 
> // 相信大部分同学都知道答案是：[‘100', '200', '300’]。
> 
> # 如果在有浮点数的情况呢？
> 
> const sorted = {}
> 
> sorted[300] = {}
> sorted[100] = {}
> sorted[200] = {}
> sorted[50.5] = {}
> 
> console.log(Object.keys(sorted)) // 这次又输出什么呢？
> 
> // 会不会有同学以为答案是：['50.5', ‘100', '200', '300’] 呢？
> 
> // 但正确的答案应该是：[‘100', '200', '300’,’50.5’]。
> ```

##### V8 内部是如何处理对象属性的

- **排序属性(elements)** ，就是符合数组索引类型的属性（也就是正整数）。
- **常规属性(properties)** ，就是字符串类型的属性（也包括负数、浮点数）。

所有的**排序属性**都会存放在一个线性结构中，线性结构的特点就是支持通过索引随机访问，所以能加快访问速度，对于存放在线性结构的属性都称为**快属性**。

**常规属性**也会存放在另一个线性结构中，可以看下面这张图帮助理解：

![1714196654072](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1714196654072.png)

V8 排序属性和常规属性

但是**常规属性**还需要做一些额外的处理，这里我们要先介绍一下什么是**隐藏类**。

由于 JavaScript 在运行时是可以修改对象属性的，所以在查询的时候会比较慢，可以看回上面那张图，每次访问一个属性的时候都需要经过多一层的访问，而像 C++ 这类静态语言在声明对象之前需要定义这个对象的结构（形状），经过编译后每个对象的形状都是固定的，所以在访问的时候由于知道了属性的偏移量，自然就会比较快。

V8 采用的思路就是将这种机制应用在 JavaScript 对象中，所以引入了**隐藏类**的机制，你可以简单的理解**隐藏类**就是描述这个对象的形状、包括每个属性对应的位置，这样查询的时候就会快很多。

关于**隐藏类**还有几点要补充：

1. 对象的第一个字段指向它的**隐藏类**。
2. 如果两个对象的形状是完全相同的，会共用同一个**隐藏类**。
3. 当对象添加、删除属性的时候，会创建一个新的对应的**隐藏类**，并重新指向它。
4. V8 有一个转换树的机制来创建隐藏类，不过本文不赘述，有兴趣可以看**这里**[18]。

解释完隐藏类，我们再回头来讲讲**常规属性**，通过上面那张图我们很容易发现一个问题，那就是每次访问一个属性的时候，都需要经过一个间接层才能访问，这无疑降低了访问效率，为了解决这个问题，V8 又引入了一个叫做**对象内属性**，顾名思义，它会将某些属性直接存放在对象的第一层里，它的访问是最快的，如下图所示：

![1714196668477](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1714196668477.png)

V8 对象内属性

但要注意，**对象内属性**只存放**常规属性**，排序属性依旧不变。而且需要常规属性的数量**小于**某个数量的时候才会直接存放**对象内属性**，那这个数量是多少呢？

答案是取决于**对象初始化时的大小**。

PS：有些文章说是少于 10 个属性时才会存放对象内属性，**别被误导了**。

除了**对象内属性**、**快属性**以外，还有一个**慢属性**。

为什么会有**慢属性**呢？**快属性**虽然访问很快，但是如果要从对象中添加或删除大量属性，则可能会产生大量时间和内存开销来维护**隐藏类**，所以在**属性过多或者反复添加、删除属性时**会将**常规属性**的存储方式从线性结构变成字典，也就是降低到**慢属性**，而由于**慢属性**的信息不会再存放在**隐藏类**中，所以它的访问会比**快属性**要慢，但是可以高效地添加和删除属性。可以通过下图帮助理解：

![1714196688413](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1714196688413.png)

V8 慢属性

写到这里，我觉得自己对 V8 的快属性、慢属性这些知识已经非常了解，简直要牛逼到上天了。

但当我看到这段代码的时候：

```js
function toFastProperties(obj) {
    /*jshint -W027*/
    function f() {}
    f.prototype = obj;
    ASSERT("%HasFastProperties", true, obj);
    return f;
    eval(obj);
}
```

关于这段代码是如何能让 V8 使用对象**快属性**的可以看这篇文章：**开启 V8 对象属性的“fast”模式**。

#### {}和[]的valueOf和toString

```js
{} 的 valueOf 结果为 {} ，toString 的结果为 "[object Object]"

[] 的 valueOf 结果为 [] ，toString 的结果为 ""
```

### function

> 在JavaScript中，函数不仅拥有一切传统函数的使用方式（声明和调用），而且可以做到像简单值一样:
>
> - 赋值（`var func = function(){}`）、
> - 传参(`function func(x,callback){callback();}`)、
> - 返回(`function(){return function(){}}`)，
>
> 这样的函数也称之为第一级函数（`First-class Function`）。不仅如此，JavaScript中的函数还充当了类的构造函数的作用，同时又是一个Function类的实例(instance)。这样的多重身份让JavaScript的函数变得非常重要。

#### 声明(创建)

```js
函数定义的三种方式:
	1. 函数声明:
		function fn() { }
	2. 函数表达式 / 函数字面量
		var fn = function() {}
    3. Function 构造函数
    	new Function() {}
```

[^字面量]: 用于表达一个固定值的表示法,又叫常量

#### 函数声明和函数表达式

声明和赋值

```js
jsvar myName = 'Lily'
```

上面这段代码可以看成是两行代码组成的：

```js
jsvar myName //声明部分
myName = 'Lily' // 赋值部分
```

函数声明

```js
function foo() {    console.log('foo')}
```

函数foo是一个完整的函数声明，没有涉及到赋值操作

函数表达式

首先，分析下面这段代码

```js
var bar = function () {     console.log('bar') }
```

当执行这段代码的时候，V8在编译阶段会先查找声明语句，你可以把这段代码拆分为下面两行代码

```js
var bar = undefined
bar = function () {    console.log('bar')}
```

第一行是声明语句，所以V8在解析阶段，就会在作用域中创建该对象，并且将该对象设置为undefined，第二行是赋值/表达式，`在编译阶段，V8并不会处理函数表达式`，所以也就不会将该函数表达式提升到作用域中了。

**变量提升**

所谓的变量提升，是指在JavaScript代码执行过程中，JavaScrpt引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。

对于变量提升，如果是一个普通变量，变量提升之后都是undefined，如果是声明的函数，那么变量提升之后的值则是函数对象。

在编译阶段，如果解析到函数声明， 那么V8会将这个函数声明转换为内存中的函数对象，并将其放在作用域中。

**JavaScript执行流程**

- 首先JavaScript引擎会将代码中声明的变量和函数保存到执行上下文的变量环境中（编译阶段）；
- 然后JavaScript引擎会把声明之外的代码编译为字节码（编译阶段）；

> 输入一段代码，经过编译后，会生成两部分内容：执行上下文（Execution context）和可执行代码。

> 执行上下文是JavaScript执行一段代码时的运行环境。

- 最后JavaScript引擎执行“可执行代码”（执行阶段）。

**测试题**

```js
var fun = function (x, y) {
    return x - y 
}

function fun (x, y) {
    return x + y
}

console.log(fun(4, 3))
```

这道题目的最终输出是：1

执行过程分析：

- 编译阶段，编译第一行代码时，会将变量fun的声明（`var fun = undefined`）保存在执行上下文的变量环境中；
- 编译阶段，编译第五行代码时，会将函数fun声明保存在变量环境中，此时函数名fun与变量名fun重名，所以fun会被重新声明为函数对象。
- 编译阶段，将声明之外的代码编译成字节码
- 执行阶段，执行第一行代码时，将变量fun赋值为`function(x, y) { return x -y }`
- 执行阶段，执行第五行时声明语句，应该不会编译为可执行代码
- 执行阶段，调用fun函数，
- 所以最终输出为1

#### 函数提升

> - JavaScript解释器中存在一种变量声明被提升的机制,也就是说函数声明会被提升到作用域的最前面,即使写代码的时候是写在最后面,也还会被提升至最前面。
>
> ```js
> fn();
> function fn(){ console.log(1) };
> // 1
> 
> var getName
> console.log(getName) // function getName(){console.log('oo')}
> getName() // 'oo'
> function getName(){console.log('oo')}
> ```
>
> - 而用函数表达式创建的函数是在运行时进行赋值,且要等到表达式赋值完成后才能调用。
>
> ```js
> fn(); // Uncaught TypeError: fn is not a function
> var fn = function (){ console.log(1) };
> 
> var getName
> console.log(getName) // undifined
> getName() // Uncaught TypeError: getName is not a function
> var getName= function(){console.log('oo')}
> ```
>
> ![1713162251693](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1713162251693.png)
>
> ```js
> # 只有声明本身会被提升，而赋值或其他运行逻辑会留在原地；
> 
> # 函数声明会被提升，但是函数表达式却不会被提升；
> 
> # 函数会优先于变量提升 ;
> 
> f(); //TypeError: f is not a function 函数表达式不会被提升
> 
> var f = function foo(){
>      console.log(a) //undefined; 声明被提升，赋值不会被提升
>     var a = 1
>  }
> ```

#### 构造函数返回值

```js
// 在传统语言中,构造函数不应该有返回值,实际执行的返回值就是此构造函数的实例化对象. 而在JS中构造函数可以有返回值也可以没有.
# 1. 没有返回值则按照其他语言一样返回实例化对象.

function Foo(name) { this.name = name }
new Foo('li') // Foo {name: "li"}

# 2. 若有返回值则检查其返回值是否为引用类型.如果是非引用类型,如基本类型(String,Number,Boolean,Null,Undefined)则与无返回值相同,实际返回其实例化对象.

function Foo(name) {
    this.name = name
    return 520
}
new Foo('li') // Foo {name: "li"}

# 3. 若返回值是引用类型,则实际返回值为这个引用类型.

function Foo(name) {
    this.name = name
    return { age:18 }
}
new Foo('li') // {age: 18}

function Foo(name) {
    this.name = name
    return [1,2,3]
}
new Foo('li') // [1, 2, 3]
```

#### arguments对象

```js
arguments对象是函数中传递的参数值的集合.
	它是一个类似数组的对象(类数组),因为它有一个length属性;
	我们可以使用数组索引表示法arguments[1]来访问单个值,但它没有数组中的内置方法,如:forEach、filter...

将arguments对象转换成一个数组:
	1. 我们可以使用 Array.prototype.slice将arguments对象转换成一个数组;
	function fn() {
		return Array.prototype.slice.call(arguments)
	}
	2. 使用es6的扩展运算符: [... arguments]
	3. 也可以使用es6的函数的剩余参数rest语法 fn(...args)
```

```js
// 箭头函数中没有arguments对象。
function one() {
  return arguments;
}
const two = function () {
  return arguments;
}
const three = function three() {
  return arguments;
}

const four = () => arguments;

four(); // Throws an error  - arguments is not defined

// 当我们调用函数four时，它会抛出一个ReferenceError: arguments is not defined error。使用rest语法，可以解决这个问题。

const four = (...args) => args;

// 这会自动将所有参数值放入数组中。
```

> 箭头函数中没有arguments对象
>
> <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1709520579205.png" alt="1709520579205" style="zoom: 67%;" />
>
> 可以使用rest语法:
>
> <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1709520629183.png" alt="1709520629183" style="zoom: 67%;" />

#### 函数的length属性

> 在JavaScript里,函数的length属性是在**函数声明时**预先设定的参数个数。这个属性仅统计预期的参数数量，**不考虑有...的剩余参数(rest parameters)，也不把默认参数计算在内**。这个属性在反射(reflection)和函数式编程中非常有用，它帮助我们了解函数预期会接收多少个参数。

```js
# 零参数的函数

function fn() {}
fn.length // 0

# 一个参数的函数

function fn(a) {}
fn.length // 1

# 多个参数的函数

function fn(a,b,c) {}
fn.length // 3

# 含有默认参数的函数,length属性只计算到第一个有默认值之前的参数

function fn(a,b=1,c) {}
fn.length // 1

# 带有剩余参数的函数,length属性仅统计...rest之前的参数个数

function fn(a,b,...rest) {}
fn.length // 2
```

```js
# 练习
123['toString'].length + '123' 结果 ?

123['toString']取值,123的toString会找到Number.prototype.toString方法。这个方法可以接受一个参数所以123['toString'].length的值就是1.
1+'123' // '1123'
```

#### 注意

```js
// 为什么在调用这个函数时，代码中的b会变成一个全局变量?
function myFunc() {
  let a = b = 0;
}

myFunc();

// 原因是赋值运算符是从右到左的求值的。这意味着当多个赋值运算符出现在一个表达式中时，它们是从右向左求值的。所以上面代码变成了这样：

function myFunc() {
  let a = (b = 0);
}

myFunc();

// 首先，表达式b = 0求值，在本例中b没有声明。因此，JS引擎在这个函数外创建了一个全局变量b，之后表达式b = 0的返回值为0，并赋给新的局部变量a。

// 我们可以通过在赋值之前先声明变量来解决这个问题。

function myFunc() {
  let a,b;
  a = b = 0;
}
myFunc();
```

#### 函数重载

```
// 函数重载
```

#### **立即执行函数**

```js
(function(){ .. })()
(function(){ .. }())
```

#### 作用域有两种工作模型

```js
1、词法作用域: 函数声明时所处的位置决定

2、动态作用域

JavaScript 中有两种机制（eval(..) 和with）
```

#### 作用域

```
 作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。

```

##### **块作用域**

```js
ES3 中try/catch 结构在catch 分句中具有块作用域
ES3 中with
ES6 中let
ES6 中const
```



#### 作用域链

```
作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和 函数。

作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前 端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。

当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。

作用域链的创建过程跟执行上下文的建立有关....
```

> 详细资料可以参考：《JavaScript 深入理解之作用域链》、「前端料包」深究JavaScript作用域（链）知识点和闭包

#### 回调函数

> **回调函数**是一段可执行的代码段，它作为一个参数传递给其他的代码，其作用是在需要的时候方便调用这段（回调函数）代码。
>
> 在JavaScript中函数也是对象的一种，同样对象可以作为参数传递给函数，因此函数也可以作为参数传递给另外一个函数，这个作为参数的函数就是回调函数。

```js
const btnAdd = document.getElementById('btnAdd');

btnAdd.addEventListener('click', function clickCallback(e) {
    // do something useless
});

// 在本例中，我们等待id为btnAdd的元素中的click事件，如果它被单击，则执行clickCallback函数。回调函数向某些数据或事件添加一些功能。
```

> 回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell）

```js
setTimeout(() => {
    console.log(1)
    setTimeout(() => {
        console.log(2)
        setTimeout(() => {
            console.log(3)
    
        },3000)
    
    },2000)
},1000)

// 这就是典型的回调地狱，以上代码看起来不利于阅读和维护，事件一旦多起来就更是乱糟糟，所以在es6中提出了Promise和async/await来解决回调地狱的问题。当然，回调函数还存在着别的几个缺点，比如不能使用 try catch 捕获错误，不能直接 return。
```

#### 高阶函数

```js
// 高阶函数只是将函数作为参数或返回值的函数。

function higherOrderFunction(param,callback){
    return callback(param);
}

# 例如以函数作为参数：

const arr = [1,2,3,4,5];
arr.map(item => item + 10)
arr.filter(item => item % 2 === 0)
numbers.reduce((accumulator, currentValue) => accumulator + currentValue);
setTimeout(() => {

}, timeout);

dom.addEventListener('click', () => {

})

# 例如以函数作为返回值：

function a(){

}
const b = a.bind({})
```

> ## 高阶函数的本质
>
> 那到底js高阶函数有什么用呢。这个问题其实涉及到高阶函数的本质。在函数式编程里面，他把每一个函数看作是一个运算，它认为函数的本质就是运算，给我一些就给你算出一些东西，而高阶函数表达是什么呢，表达的是运算的缺失和延续，怎么理解，我们先来看缺失。
>
> 我们来看看这个map，当你自己去写一个map函数的时候，你会怎么写呢，我的目标是返回一个数组，遍历原数组，经过一套规矩，转换成新的值，把新的值，放到新的数组里，它的基本逻辑就是这样。
>
> ```js
> function map() {
>   const result = [];
>   for (let i = 0; i < 愿数组.length; i++) {
>     愿数组[i] --> 新的值
>     result.push(新的值)
>   }
> }
> ```
>
> 但是你仔细想想，在上面代码，是不是有个拼图是缺失的，什么拼图，就是
>
> ```js
> 愿数组[i] --> 新的值
> ```
>
> 这里需要一个运算，把原数组里面的值通过一定的运算，转换成新的值，我在写这个函数的时候，缺失了一个运算，而这个运算，本质上就是一个函数，你需要给我传进来，把这个拼图补上，
>
> ```js
> function map(fn) {
>   const result = [];
>   for (let i = 0; i < 愿数组.length; i++) {
>     const 新的值 = fn(愿数组[i])
>     result.push(新的值)
>   }
> }
> ```
>
> 所以，如果函数作为参数进来，那么就意味着这个方法有个运算的缺失，需要用高阶函数来表达。
>
> 而另一方面，你写一个bind函数。
>
> ```js
> function bind(thisArg) {
>    const fn = 绑定了this的函数，
>    return fn;
> }
> ```
>
> 这个bind函数，只负责生成这个函数，但是这个函数在什么时候运行，我不知道，也可以现在调用，也可以将来某个时候运行，都不清楚，那怎么办呢，那就把这个函数返回.
>
> 用的人，拿到这个返回值，就拿到这个函数，将来他在任何时候都可以调用这个函数，实际上调用的是bind函数里面的功能。也就是，虽然bind执行完啦，但是没有结束，他的功能会延续到外层，在将来的某个时候发挥作用，这个就是运算的延续。
>
> ## 总结
>
> 我们在运算缺失的时候，需要函数作为参数，我们需要对运算作为延续的时候，需要函数作为返回值。

#### 函数柯里化

```js
// 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。

function curry(fn, args) {
  // 获取函数需要的参数长度
  let length = fn.length;

  args = args || [];

  return function() {
    let subArgs = args.slice(0);

    // 拼接得到现有的所有参数
    for (let i = 0; i < arguments.length; i++) {
      subArgs.push(arguments[i]);
    }

    // 判断参数的长度是否已经满足函数所需参数的长度
    if (subArgs.length >= length) {
      // 如果满足，执行函数
      return fn.apply(this, subArgs);
    } else {
      // 如果不满足，递归返回科里化的函数，等待参数的传入
      return curry.call(this, fn, subArgs);
    }
  };
}

// es6 实现
function curry(fn, ...args) {
  return fn.length <= args.length ? fn(...args) : curry.bind(null, fn, ...args);
}
```

> 《JavaScript 专题之函数柯里化》

#### 练习

```js
function Foo() {
    getName = function () { alert(1) }
}
Foo.getName = function () { alert(2) }
Foo.proptotype.getName = function () { alert(3) }
var getName = function () { alert(4) }
function getName() { alert(5) }

Foo.getName()
getName()
Foo().getName()
getName()
new Foo.getName()
new Foo().getName()
new new Foo().getName()

// 2 4 1 1 2 3 3
```

## 数据类型转换

Javascript 是一种弱类型语言，这意味着变量是没有明确类型的，而是由 JavaScript 引擎在编译时隐式完成。类型转换就是将一种数据类型转换为另一种数据类型，例如：

```js
20 + "twenty" // "20twenty"
"10" * "10"   //  100 
2 - "x" 
```

Javascript 使用严格相等（===）和宽松相等（==）来测试两个值的相等性，类型转换仅在使用宽松相等运算符时发生。当使用 === 测试严格相等时，要比较的变量的类型和值都必须相同，例如：

```js
10 === 10     // true
NaN === NaN   // false
```

在上面的代码中，10和10都是数字并且是完全相等的，所以正如预期的那样返回了`true`，两个 NaN 永远不会相等。当使用 == 测试宽松相等时，可能会发生隐式转换：

```js
'20' == 20    // true
false == 0    // true
```

对于任何数据类型，无论是原始类型还是对象，都可以进行类型转换。尽管原始类型和对象的转换逻辑各不相同，但是都只能转换为三种类型：**字符串（string）、数字（number）、布尔值（boolean）**。

> JS 中类型转换只有三种情况，分别是：
>
> - 转换为布尔值（调用Boolean()方法）
>
> - 转换为数字（调用Number()、parseInt()和parseFloat()方法）
>
> - 转换为字符串（调用.toString()或者String()方法）
>
> - null和underfined没有.toString方法
>
>   ![1710581024695](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1710581024695.png)

JavaScript 中的类型转换有两种方式：

- **隐式类型转换：** 由 JavaScript 编译器完成的自动类型转换。
- **显式类型转换：** 由开发人员完成的手动类型转换。

### （1）显示类型转换

我们可以通过 JavaScript 内置的一些 API 将一种类型转换为另一种类型，这称为显式类型转化。执行显式类型转换的最简单方法是使用 `Boolean()`、`Number()` 和 `String()`、`parseInt()`等函数，例如：

```js
String(2 - true);     // '1'
'56' === String(56);  // true
Number('2350e-2');    // '23.5'
Number('23') + 7;     // 30
Boolean('');          // false
Boolean(2) === true;  //true
```

### （2）隐式类型转换

隐式类型转换是将一种数据类型转换为另一种数据类型（确保在相同数据类型之间完成操作）以使运算符或函数正常工作，这种转换是由 JavaScript 编译器自动完成的，隐式类型转换也称为类型强制。例如：

```js
'25' + 15;          // '2515'
23 * '2';           // 46
23 - true;          // 22
true - null;        // 1
false + undefined;  // NaN

const arr = [];
if(arr) { console.log('Hello World') };
```

下面这些常见的操作会触发隐式地类型转换，编写代码时要格外注意：

- 运算相关的操作符：+、-、+=、++、* 、/、%、<<、& 等。
- 数据比较相关的操作符： >、<、== 、<=、>=、===。
- 逻辑判断相关的操作符： &&、!、||、三目运算符。

#### ① + 运算符

```js
/* 一个操作数 */
+ x // 将x转化为数字, 如果不能转化为数组将输出NaN
+ "1234string"   // NaN 
+ 1              // 1
+ '1'            // 1
+ true           // 1
+ undefined      // NaN
+ null           // 0
+ new Date()     // 1660493819396

/* 两个操作数 */
a + b

// 1. 如果其中任何一个是对象，则先将其转换为原始类型
{} + {}          // '[object Object][object Object]'
[] + []          // ''
[] + new Date()  // 'Mon Aug 15 2022 00:18:18 GMT+0800 (中国标准时间)'

// 2. 如果一个是字符串，则将另一个转换为字符串
1 + ''           // '1'
'' + 1           // '1'
'' + true        // 'true'

// 3. 否则，将两者都转换为数字
1 + true         // 2
true + true      // 2
```

#### ② -、*、/、++、--

```js
// 将一个或多个值转换为数字
 - '1'     // -1
 [] - 1    // -1
 [] - {}   // NaN
```

#### ③ ==、!=

```js
// 两个操作数
 a == b

// 1. 如果一个是 `null` 而另一个是 `undefined`，它们是相等的
null == undefined    // true

// 2. 如果一个是数字，另一个是字符串，将字符串转换为数字，再比较
1 == '1'             // true

// 3. 如果其中一个是布尔值，将其转换为数字，再次比较
true == 1            // true
false == 0           // true

// 4. 如果一个是对象，另一个是数字或字符串，将对象转换为原始类型，再次比较
[1] == 1             // true
['1'] == '1'         // true
```

下图是在使用 == 时，判断两个操作数是否相等的总结（绿色表示相等，白色表示不等）：

![1712386487398](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1712386487398.png)

#### ④ >、>=、<、<=

```js
// 两个操作数
a > b

// 1. 如果其中一个是对象，则将其转换为原始类型，再次比较
[2] > 1   // true

// 2. 如果两者都是字符串，使用字母顺序比较它们
'b' > 'a' // true

// 3. 如果其中一个是数字，则将一个或两个非数字转换为数字
'2' > 1   // true
```

#### ⑤ in

```js
/* 如果左操作数不是字符串，则将其转换为字符串 */
 a in b

'1' in {1: ''}    // true
 1 in {1: 'a'}    // true
 1 in ['a', 'b']  // true
```

### 常见类型转换

### （1）字符串转换

将数据类型转换为字符串称为字符串转换，可以使用 `String()` 函数将数据类型显式转换为字符串。当一个操作数是字符串时，可以通过使用 `+` 运算符来触发隐式字符串转换。

#### ① 数字 => 字符串：

Number对象的 `toString()` 方法会返回指定 Number 对象的字符串表示形式。`String()`和 `new String()` 会把对象的值转换为字符串。

```js
String(20);           // '20'
String(10 + 40);      // '50'
(10 + 40).toString(); // '50'
new String(10 + 20);  // '30'
```

#### ② 布尔值 => 字符串：

`String()` 和 `toString()` 方法会将布尔值转化为对应的字符串形式。

```js
String(true);     // 'true'
String(false);    // 'false'
true.toString()   // 'true'
false.toString()  // "false"
```

#### ③ 数组 => 字符串：

`String()` 方法会将数组元素通过逗号连接起来，无论嵌套多少层，都会将其展开并返回元素拼接好的字符串。如果是空数字，会返回空字符串：

```js
String([1, 2, 3]);                // '1,2,3'
String([1, 2, 3, [4, [5]]]);      // '1,2,3,4,5'
String([1, 2, 3, [4, [5, {}]]]);  // '1,2,3,4,5,[object Object]'
String([]);                       // ''
```

#### ④ 对象 => 字符串：

使用 String() 方法会将对象转化为 `'[object Object]'`，无论对象是否为空对象：

```js
String({name: "Hello"});   // '[object Object]'
```

#### ⑤ null / undefined / NaN => 字符串：

使用 `String()` 方法会将  `null`、`undefined`、`NaN` 转化为其对应的字符串形式：

```js
String(undefined);    // 'undefined'
String(null);         // 'null'
String(NaN);          // 'NaN'
```

#### ⑥ 日期 => 字符串：

```js
String(new Date('2022-08-20')) // 'Sat Aug 20 2022 08:00:00 GMT+0800 (中国标准时间)'
```

#### ⑦ 隐式转换

当任何数据类型使用`+`运算符与字符串连接时会发生到字符串的转换（隐式转换）:

```js

"25" + 56;              // '2556'
"25" + null;            // '25null'
"Hello " + undefined;   // 'Hello undefined'
"25" + false;           // '25fasle'
"25" + {};              // '25[object Object]'
"25" + [10];            // '2510'
```

所以，当我们想要创建一个操作并且操作数类型之一是字符串时，应该小心使用类型强制转换。

#### ⑧ 总结

下面是 ECMAScript 规范中将数据类型转换为字符串的规则：

![1712386879450](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1712386879450.png)

**ECMAScript 规范：**https://262.ecma-international.org/5.1/#sec-9.8

### （2）布尔转换

将数据类型转换为布尔值称为布尔转换。这种转换既可以由 `Boolean()` 函数显式完成，也可以在逻辑上下文中隐式完成（如if/else ）或通过使用逻辑运算符（ ||、&&、! ）触发。

#### ① 字符串 => 布尔值：

使用 `Boolean()` 方法转化字符串时，只有当字符串为空时会返回`false`，其他情况都会返回 `true`：

```js
Boolean('hello'); // true 
Boolean(' ');     // true 
Boolean('');      // false
```

#### ② 数字 => 布尔值：

使用 `Boolean()` 方法转化数字时，只有 0、-0 或 NaN 会转化为 `false`，其他情况会返回 `true`：

```js
Boolean(-123); // true 
Boolean(123);  // true 
Boolean(0);    // false
Boolean(-0);   // false
Boolean(NaN);  // false
```

#### ③ 数组 / 对象 => 布尔值：

使用 `Boolean()` 方法转化数组或对象时，无论数组和对象是否有内容，都会返回`true`：

```js
Boolean([1, 2, 3]); // true
Boolean([]);        // true
Boolean({});  // true
Boolean({'hello': 'world'});  // true
```

#### ④ null / undefined => 布尔值：

使用 `Boolean()` 方法转化`null`或`undefined`时，都始终返回 `false`：

```js

Boolean(undefined);  // false 
Boolean(null);       // false
```

#### ⑤ 隐式转换

在数学运算中，`true` 转换为 1，`false` 转换为 0：

```js
true + 5;    // 6
false + 5;   // 5
5 - true;    // 5
5 - false;   // 4
```

#### ⑥ 逻辑运算符、逻辑上下文

```js
// 如果其中一个不是布尔值，则将其转换为布尔值
Boolean( null || undefined || 0 || -0 || NaN || '' )    // false
Boolean( 1 && 'a' && { } && [] && [0] && function(){} ) // true
true && false // false
true && true // true
true || false // true
true || !false // true
```

注意，逻辑运算符，例如 `||` 或 `&&` 内部进行布尔转换，但实际上返回原始操作数的值，即使它们不是布尔值。

```js
'hello' && 123;   // 123
```

可以使用双感叹号（`!!`）来将变量转为为布尔值：

```js
!!0    // false
!!""   // false
!!" "  // true
!!{}   // true
!![]   // true
!!true // true
```

if、else if、while、do/while 和 for 使用与 &&、||、! 相同的隐式类型转换方式（逻辑表达式）。

下面是在 if 语句（逻辑上下文）中的隐式转换规则（绿色为`true`，白色为`false`）：

![1712386985995](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1712386985995.png)

#### ⑦ 总结

除了下面这些之外的所有其他值都是真值，包括对象、数组、日期等。甚至所有Symbol、空对象和数组都是真值。

```js
Boolean('');        // false
Boolean(0);         // false     
Boolean(-0);        // false
Boolean(NaN);       // false
Boolean(null);      // false
Boolean(undefined); // false
Boolean(false);     // false
```

```js
Boolean({})             // true
Boolean([])             // true
Boolean(Symbol())       // true
Boolean(function() {})  // true
```

可以通过以下方式来过滤数组中的假值：

```js
[0, "", " ", null, undefined, NaN].map(Boolean); 
// 输出结果：[false, false, true, false, false, false]
```

我们可以会遇到一种情况，当使用 `5 == true` 时，结果为`false`，而使用`if(5) {}`时，则 5 被认为是 `true` 并进入`if/else`语句：

```js
5 == true;  // false

if (5) {
    console.log('5');  // 5
};
```

这种情况下，即一个值和数字进行比较时，JavaScript 会试图将这个值转换为数字。所以，当比较`5 == true` 时，JavaScript 倾向于将`true`转换为1，因为 1不等于5，因此结果为 `false`。而在`if(5) {}`的情况下，5 被转换为布尔值，而 5 是一个真值，所以它进入`if`块。在这种情况下，可以选择显式转换以避免错误，因为 5 是一个真值，可以执行`Boolean(5) == true`，这样就会返回`true`了。

下面是 ECMAScript 规范中将数据类型转换为布尔值的规则：

![1712387091868](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1712387091868.png)

**ECMAScript 规范：**https://262.ecma-international.org/5.1/#sec-9.2

### （3）数字转换

将数据类型转换为数字称为数字转换，可以使用`Number()`、`parseInt()`、`parseFloat()`等方法将数据类型显式转换为数字。当一个值不能被强制转换为一个数字时，就会返回 `NaN`。

#### ① 字符串 => 数字：

当把字符串转换为数字时，JavaScript 引擎首先会修剪前导和后置空格、`\n`、`\t` 字符，如果修剪后的字符串不代表有效数字，则返回 `NaN`。 如果字符串为空，则返回 0。

```js
Number('123');            // 123
Number("-12.34")          // -12.34
Number("12s");            // NaN
Number("\n")              // 0

parseInt(' 203px');       // 203 
parseInt('10.000')        // 10   
parseInt('10.20')         // 10 
parseFloat('203.212px');  // 203.212
parseFloat('10.20')       // 10.2
parseFloat('10.81')       // 10.81
```

可以看到，`parseInt` 函数会从字符串中读取一个数字并删除它后面所有字符，但是如果数字前面有字符（空格除外），那么它将输出 `NaN`。

#### ② 布尔值 => 数字：

当使用 `Number()` 将布尔值转化为数字时，`true` 会转化为 1，`false` 会转化为 0。

```js

Number(true);  // 1
Number(false); // 0
```

#### ③ null  => 数字：

当使用 `Number()` 将 `null` 转化为数字时，会返回 0：

```js
Number(null); // 0
null + 5; // 5
```

#### ④ undefined / 数组 / 对象 / NaN => 数字：

当使用 `Number()` 将 `undefined`、数组、对象、`NaN` 转化为数字时，会返回 `NaN`：

```js
Number(undefined);  // NaN
Number([1, 2, 3])   // NaN
Number({})          // NaN
Number(NaN)         // NaN
```

#### ⑤ 数组元素

可以使用`map`遍历数组元素，并使用需要的类型来进行类型转换：

```js
["1", "9", "-9", "0.003", "yes"].map(Number);
// 输出结果：[1, 9, -9, 0.003, NaN]
```

#### ⑥ 特殊规则

在表达式中，当我们将 `==` 运算符应用于 `null` 或 `undefined` 时，不会发生数字转换。 此外，`null` 只等于 `null` 或 `undefined`，不能等于其他任何值：

```js

null == null;           // true 
null == 0;              // false
null == undefined;      // true
undefined == undefined  // true
```

根据运算符优先级，`+` 运算符具有从左到右的关联性，因此如果有一个表达式 `2 + 3 + '4' + 'number'` ，则操作按以下方式完成：

```js
2 + 3 + '4' + 'number'
==> 5 + '4' + 'number'
// 数字 5 被隐式转换为字符串，然后连接起来
==> '54' + 'number'
==> '54number'
```

`NaN` 不等于任何其他类型，甚至它本身：

```js
NaN == NaN  // false
```

#### ⑦ 总结

上面的例子中，可以清楚地看到一些意想不到的结果：将 `null` 转换为数字时返回了 0，而将 `undefined` 转换为数字返回了 `NaN`。两个操作都应该返回 `NaN`，因为这两种值类型显然都不是有效的数字，将空字符串转换为数字时也返回了 0。

下面是 ECMAScript 规范中将数据类型转换为字符串的规则，清楚的解释了上面的异常现象：

![1712387115221](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1712387115221.png)

另外，在 ECMAScript 规范中，还提到一点：

![1712387136690](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1712387136690.png)

意思就是：**为空或仅包含空格的 StringNumericLiteral 将转换为 +0**。这也就解释了为什么将空字符串转换为数字时也返回了 0。

**ECMAScript 规范：**https://262.ecma-international.org/5.1/#sec-9.3

### Symbol 类型转换

`Symbol`  只能进行显式转换，不能进行隐式转换。也就是说，`Symbol`不能被强制转换为字符串或数字，这样它们就不会被意外地用作本来应该表现为 `Symbol` 的属性。

```js
const mySymbol = Symbol.for("mySymbol");
const str = String(mySymbol);

console.log(str);  // 'Symbol(mySymbol)'
```

当使用 `console.log()` 来打印 `symbol` 时，它之所以有效，是因为 `console.log()` 在 `symbol` 上调用了 `String()` 方法以创建可用的结果。

如果尝试直接使用字符串连接 `symbol`，它将抛出`TypeError`：

```js
const mySymbol = Symbol.for("mySymbol");
const sum = mySymbol + "";
console.log(sum);   // Uncaught TypeError: Cannot convert a Symbol value to a string
```

将 `mySymbol` 连接到字符串需要首先将 `mySymbol` 转换为字符串，并且在检测到强制转换时会抛出错误，从而阻止以这种方式使用它。

同样，我们不能将 `symbol` 强制转换为数字，所有数学运算符在与符号一起使用时都会引发错误：

```js
const mySymbol = Symbol.for("mySymbol");
const factor = mySymbol / 2;
console.log(factor);   // Uncaught TypeError: Cannot convert a Symbol value to a number
```

### **对象类型转换**

介绍完了基本数组类型的转化，下面来看看对象类型的转化。例如，当执行 `obj_1 + obj_2` 或者 `obj_1 - obj_2`时，都会先将对象转换为原始类型，然后将其转换为最终类型。当然，这里的转化仍然只有三种类型：数字、字符串和布尔值。

对象通过内部的 `ToPrimitive` 方法将其转换为原始类型，该算法允许我们根据使用对象的上下文来选择应如何转换对象。从概念上讲，ToPrimitive 算法可以分为两部分：Hints 和 Object-to-primitive 转换方法。

![1712387361824](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1712387361824.png)

### （1）Hints

Hints 是 `ToPrimitive` 算法用于确定对象在特定上下文中应转换为什么的信号。有三种情况：

- `string`：在操作需要字符串的上下文中，如果可以转换为字符串，例如 `alert()` 或内置 `String()` 函数：

```js
alert(obj);
String(obj)

// 使用对象作为属性key值
anotherObj[obj] = 1000;
```

- `number`：如果可以进行这种转换，则在操作需要数字的上下文中：

```js
// 显示转换
let num = Number(obj);

// 数学（二进制加号除外）
let x = +obj; // 一元加
let difference = Date1 - Date2; // 日期对象

// 对象大小比较
let less = Obj1 < obj2;
```

- `default`：在极少数情况下发生，不确定需要什么类型。例如，二元 + 运算符既适用于字符串（连接它们）也适用于数字（添加它们）。在这种情况下，对象可以转换为字符串或数字。 或者当使用宽松相等 == 运算符将对象与字符串、数字或 symbol 进行比较时。

```js
// 二元加
let sum = obj1 + obj2;

// obj == string/number/symbol
if (obj == 10 ) { ... };
```

所有内置对象（日期除外）都将`default`认为是`number`，Date 日期对象将`default`认为是`string`。

### （2）Methods

在 ToPrimitive 算法根据 `Hints` 确定对象应转换为的原始值类型之后。 然后使用 Object-to-primitive 转换方法将对象转换为原始值。有三种情况：

- `toString/valueOf`：`toString()` 和 `valueOf()` 被 JavaScript 中的所有对象继承。 它们仅用于对象到原始值的转换。 ToPrimitive 算法首先会尝试 `toString()` 方法。 如果定义了方法，它返回一个原始值，那么 JavaScript 使用原始值（即使它不是字符串）。 如果`toString()` 返回一个对象或不存在，那么 JavaScript 会尝试使用 `valueOf()` 方法，如果该方法存在并返回一个原始值，JavaScript 将使用该值。 否则，转换失败并提示 `TypeError`。
- `toString -> valueOf`：用于 Hints 为`string` 的情况。
- `valueOf -> toString`：其他情况。

```js
let Person = {
  name: "Mary",
  age: 22,

  // hint 是 "string"
  toString() {
    return `{name: "${this.name}"}`;
  },

  // hint 是 "number" 或 "default"
  valueOf() {
    return this.age;
  }
};

alert(Person);      // toString -> {name: "Mary"}
alert(+Person);     // valueOf -> 22
alert(Person + 10); // valueOf -> 32
```

在上面的代码中，`Person` 变成了一个对象字符串或数字，具体取决于转换上下文。 `toString()` 方法用于 Hints = "string" 的转换，`valueOf()` 用于其他情况（Hints 为“number”或“default”）。

你可能希望在一个地方处理所有转换。 在这种情况下，只能像这样实现 `toString()` 方法：

```js
let Person = {
  name: "Mary",

  toString() {
    return this.name;
  }
};

alert(Person); // toString -> Mary
alert(Person + 1000); // toString -> Mary1000
```

`Symbol.toPrimitive`：与 `toString()` 和 `valueOf()` 方法不同，`Symbol.toPrimitive` 允许覆盖 JavaScript 中的默认对象到原始值的转换（其中 `toString()` 和 `valueOf` 方法由 ToPrimitive 算法使用）并定义我们希望如何将对象转换为原始类型的值。 为此，需要使用此 Symbol 名称定义一个方法，如下所示：

```js
obj[Symbol.toPrimitive] = function(hint) {
  // 返回原始类型值
  // hint 等于 "string", "number", "default" 中的一个
}
```

例如，这里的 `Person` 对象使用 `Symbol.toPrimitive` 执行与上面相同的操作：

```js
let Person = {
  name: "Mary",
  age: 22,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.age;
  }
};

alert(Person);       // hint: string -> {name: "Mary"}
alert(+Person);      // hint: number -> 22
alert(Person + 10);  // hint: default -> 32
```

可以看到，单个方法 `Person[Symbol.toPrimitive]` 处理了所有转换情况。需要注意，在没有 `Symbol.toPrimitive` 和 `valueOf()` 的情况下，`toString()` 将处理所有原始类型转换。

下面是将对象转化为布尔值、字符串、数字时的执行过程：

**（1）对象到布尔值的转换**

Javascript 中的所有对象都转换为 true，包括包装对象 new Boolean(false) 和空数组。 对象到布尔值的转换不需要对象到原始类型算法。

**（2）对象到字符串的转换**

当需要将对象转换为字符串时，Javascript 首先使用 ToPrimitive 算法（Hints = “string”）将其转换为原始类型，然后将派生的原始类型转换为字符串。例如，如果将对象传递给 String() 这样的内置函数，或者在模板字符串中插入对象时。

**（3）对象到数字的转换**

当需要将对象转换为数字时，Javascript 首先使用  ToPrimitive  算法（Hints = “number”）将其转换为原始类型，然后将派生的原始类型转换为数字。 期望数字参数的内置 Javascript 函数和方法以这种方式将对象参数转换为数字，例如 Math()。

### （3）特殊情况

当某些 Javascript 运算符的操作数是对象时，也会发生类型转换：

- **+ 运算符：** 此运算符可以用于执行数字加法和字符串连接。如果其中任何一个操作数是对象，则使用  ToPrimitive 算法（Hints = “default”）将它们转换为原始值。一旦将它们转换为原始值，就会检查它们的类型。如果任一参数是字符串，则将另一个参数转换为字符串并连接字符串。否则，它将两个参数都转换为数字并将它们相加。
- **== 和 !== 运算符：** 这些运算符以宽松方式执行相等和不相等测试。如果一个操作数是一个对象而另一个是一个原始值，这些运算符使用  ToPrimitive  算法（Hints = “default”）将对象转换为原始值，然后比较两个原始值。
- **<,<=,> 和 >= 关系运算符：** 关系运算符用于比较两个值之间的关系，可用于比较数字和字符串。如果任一操作数是对象，则使用 ToPrimitive 算法将其转换为原始值（Hints = “number”）。但是，与对象到数字的转换不同，返回的原始值不会转换为数字（因为它们被比较并且不被使用）。

## 数据类型的判断

### typeof

> typeof运算符可以返回一个值的数据类型。

```js
// typeof 对于原始类型来说，除了 null 都可以显示正确的类型

console.log(typeof 2);               // number
console.log(typeof true);            // boolean
console.log(typeof 'str');           // string
console.log(typeof []);              // object     []数组的数据类型在 typeof 中被解释为 object
console.log(typeof function(){});    // function
console.log(typeof {});              // object
console.log(typeof undefined);       // undefined
console.log(typeof null);            // object     null 的数据类型被 typeof 解释为 object

typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 instanceof
```

### instanceof

> instanceof运算符用于检查一个对象是否属于某个特定的类或构造函数的实例。

```js
instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。

console.log(2 instanceof Number);                    // false
console.log(true instanceof Boolean);                // false 
console.log('str' instanceof String);                // false  
console.log([] instanceof Array);                    // true
console.log(function(){} instanceof Function);       // true
console.log({} instanceof Object);                   // true    
// console.log(undefined instanceof Undefined);
// console.log(null instanceof Null);

可以看出直接的字面量值判断数据类型，instanceof可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断。

我们来看一下 instanceof 在MDN中的解释：instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。其意思就是判断对象是否是某一数据类型（如Array）的实例，请重点关注一下是判断一个对象是否是数据类型的实例。在这里字面量值，2， true ，'str'不是实例，所以判断值为false。
```

> 实现 instanceof：
>
> ```
> 1. 首先获取类型的原型
> ```
>
> ```
> 2. 然后获得对象的原型
> ```
> ```
> 3. 然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null
> ```

```js
// 1.
function myInstanceof(left, right) {
  let prototype = right.prototype
  left = left.__proto__
  while (true) {
    if (left === null || left === undefined)
      return false
    if (prototype === left)
      return true
    left = left.__proto__
  }
}
// 2
function myInstanceOf(son,father) {//沿着父亲的原型链向上查找是否有儿子的原型
 while (true) {
  son=son.__proto__
  if (!son) return false
  if (son===father.prototype) return true
 }
}

myInstanceOf([], Array)  // true
```

### constructor

```js
console.log((2).constructor === Number); // true
console.log((true).constructor === Boolean); // true
console.log(('str').constructor === String); // true
console.log(([]).constructor === Array); // true
console.log((function() {}).constructor === Function); // true
console.log(({}).constructor === Object); // true

// 这里有一个坑，如果我创建一个对象，更改它的原型，constructor就会变得不可靠了

function Fn(){};
 
Fn.prototype=new Array();
 
var f=new Fn();
 
console.log(f.constructor===Fn);    // false
console.log(f.constructor===Array); // true 
```

### Array.isArray()

> Array.isArray()方法可以判断一个值是否为数组类型。

```js
Array.isArray([]); // true
Array.isArray({}); // false
```

### Object.prototype.toString.call()

> 这是一种通用的方式，可以对任意值进行类型判断。

```js
Object.prototype.toString.call() 使用 Object 对象的原型方法 toString ，使用 call 进行狸猫换太子，借用Object的 toString 方法

Object.prototype.toString.call(42); // "[object Number]"
Object.prototype.toString.call("hello"); // "[object String]"
Object.prototype.toString.call(true); // "[object Boolean]"
Object.prototype.toString.call(undefined); // "[object Undefined]"
Object.prototype.toString.call(null); // "[object Null]"
Object.prototype.toString.call({}); // "[object Object]"
Object.prototype.toString.call([]); // "[object Array]"
Object.prototype.toString.call(function() {}); // "[object Function]"
```

