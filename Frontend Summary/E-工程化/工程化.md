## 工程化意义

```text
前端开发的管理工具，提升开发效率
```

### 一、模块化

```text
分解与聚合
```

#### 模块化的发展流程

###### 1.初始以文件来区分模块

```
缺点：
	全局污染
	依赖混乱
```

###### 模块化的标准

|          标准           |                开发                | 官方标准 |                       执行方式                       |                使用                 |
| :---------------------: | :--------------------------------: | :------: | :--------------------------------------------------: | :---------------------------------: |
|     CommonJs /  CJS     |               nodejs               |    /     |           运行时--代码运行时，确定依赖关系           | 导入--require；导出--module.exports |
|           AMD           |                 /                  |    /     |                          /                           |                  /                  |
|           CMD           |                 /                  |    /     |                          /                           |                  /                  |
|           UMD           |                 /                  |    /     |                          /                           |                  /                  |
| SCMAScript Module / ESM | es6 / nodejs现在既支持CJS也支持ESM |    √     | 编译时--但是es7时的动态导入 @import('xx') 属于运行时 |     导入--import；打出--export      |

```
可以运行个模块化标准的环境：
	浏览器：ESM
	node：CJS/ESM
	构建工具：CJS/ESM
```

------

#### 包管理

```
package,一系列模块的集合。 函数--->模块--->包
```

```
从哪里下载包？
如何升级包？
如何卸载包？
如何发布包？
版本控制。
	这些都需要‘包管理’
```

```
node环境：
	npm pnpm yarn cnpm
浏览器环境：
	bower
```

npm存在幻影依赖的问题

#### 工程化需要解决的问题

##### 1. 语言问题

```
html、css、js很难适应复杂的工程化
```

###### a. html

```
现在大部分是单页面应用，整个页面的元素靠js的document.createElement 动态生成
```

###### b. css

```
1. 语法缺失：
	循环、判断、字符串拼接等逻辑性的语法是缺失的
2. 功能缺失：
	函数
	
	既然css语言缺失太多，那就重新写一套新的语言，在css语言基础上扩展大部分东西，如:scss、less、stylus	
```

<img src="C:\Users\Administrator\Desktop\Frontend Summary\E-工程化\屏幕截图 2024-02-28 135726.png" alt="屏幕截图 2024-02-28 135726" style="zoom: 50%;" />

```
	新语言是css的超集，css有的新语言有，css没有的新语言还有，但是，浏览器不识别新的语言，所以需要工具去编译，新语言通过’编译器‘转成css。
	这个编译器就是-->css预编译器（scss、less、stylus）
```

新语言经过css预编译器编译后的css代码，还有一些问题需要解决：

```
1. 厂商前缀的问题  -o、-webkit...
2. 代码压缩   空格、空行 去掉，提升运行效率
3. 代码剪枝  页面中原先用到的css，经过一些改变后用不到了，这些css不需要生成到最终的css代码中

这些问题需要工具去解决：
1. autoprefixer 解决厂商前缀
2. cssnano 可以代码压缩
3. purgecss 进行代码剪枝
4. css module 解决代码冲突
这些工具称为 css后处理器
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1709101099428.png" alt="1709101099428" style="zoom:50%;" />

```
预处理器将 新语言 转换 成 css
后处理器将 css	转换 成 css
postcss 就是 将这些转换逻辑抽离，而成的工具；与 babel类似，也需要插件支持。
	postcss
	postcss-cli
```

postcss配置

```javascript
// postcss.config.js
module.exports = {
    map: false, // 不生成surce-map  .map文件
    plugins: {
        tailwindcss:{}, // 原子css
        'postcss-preset-env':{}, // 预设
        'postcss-modules':{} // css module
    }
}
```

###### c. js

```
1.兼容性问题：
	a. API兼容：
		新的API在老版本浏览器（node）中不兼容，不能使用。
		这就需要在老版本中重写一个功能相同在老版本中运行的api这种做法叫做 polyfill
		polyfill：垫片/填充物；在老版本缺失这样的api重新填充一个。
		但是，手动填充会影响开发效率，需要一个工具帮我们完成这样的事情--->现在主流的是core-js,并不是所有的东西都可以polyfill。
	
	b. 语法兼容：
		API兼容可以填充API，而语法兼容需要对语法进行 ‘语法转换’。syntax transformer / runtime
		例如: async await 老版本不兼容es6，所以需要一个工具将 async await转换成老版本识别的语法，并且功能还在；regenerator将async await语法编译成另一段代码。
		到现在，解决语法兼容，一个工具解决一个或多个语法兼容问题，在开发中工具这么多，需要我们将这些工具整合起来。
		代码集成转换工具，用的最多的就是babel，babel将这些工具集成进来。
		
		@babel/core babel核心，提供转换代码的API （regenerator...）
		@babel/cli 命令行工具，可以在命令行输入命令，直接转换。
		
		babel会将代码转为AST语法树，结果与原代码没有太大区别，这是因为 还需要对应的插件
		
```

<img src="C:\Users\Administrator\Desktop\Frontend Summary\E-工程化\屏幕截图 2024-02-28 111559.png" alt="屏幕截图 2024-02-28 111559" style="zoom:50%;" />

```text
		例如：obj?.foo?.bar 转换还需要 @babel/plugin-transform-optioanal-chaining,并且配置babel.config.js.
        现在还是需要一个个下载插件，插件那么多也不可能所有的都记住，所有我们用到了 预设；
        预设：一堆插件，都已经配置好了，直接使用就可以。
        
        babel中有许多预设： 支持ts的预设/支持jsx的预设/基础预设@babel/preset-env
```

**babel.config.js**

```javascript
module.exports = {
    presets:[
        '@babel/preset-env'
        // 对预设需要进行一些配置 可以使用 []
        ['@babel/preset-env',{
            target:{ // 要兼容的浏览器信息  等同 browser list
                edge:'17',
                firefox:'60'
            },
            useBuiltIns: 'usage', //按需导入
            corejs:'3.32.2' // core-js 的版本
        }]
    ]
}
```

```
2. 语法增强
	语法兼容即可以处理兼容 也可以处理语法增强，都需要一个工具将代码进行转换-- babel
```

> 与babel功能相似的工具--swc(转换速度更快，使用rust编写)

##### 2. 工程问题

```
上边都是语言方面的处理，也就是代码层面的转换；
那么工程层面也需要进行转换，这就用到了： 构建工具、脚手架

开发和维护的代码 --> 需要转换 --> 运行时需要的代码
开发和维护的工程 --> 需要转换 --> 运行时需要的工程
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1709102263380.png" alt="1709102263380" style="zoom: 50%;" />

```
上面的工程（开发和维护的工程） 经过 构建工具 的转换，转换成下面‘运行时需要的工程’
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1709102818908.png" alt="1709102818908" style="zoom:50%;" />

###### 构建工具

```
构建工具需要做什么？
	那种工程更适合加法和维护？
	那种工程更适合运行时？
	如何转换（打包）
所以形成了多种构建工具： webpack、rollup、esbuild

webpack :一切皆为模块
```

###### 开发服务器

```
	工程中代码经过 添加/修改后，想要看到效果，就需要转换为传统工程（html、css、js），这样太麻烦，所以就有了开发服务器。
	npm run serve 就会运行开发服务器
	开发服务器 用到 webpack-dev-server 核心是express
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1709105259315.png" alt="1709105259315" style="zoom:50%;" />

```
文件指纹  hash/contenthash  [hash:8]
```

###### 脚手架

```
界面交互
工程模板
```

##### 3. 流程问题

```
涉及架构
```

