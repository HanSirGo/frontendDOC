## 工程化

![1712477928442](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1712477928442.png)

### 规范化

- `格式规范化`
- `提交规范化`
- `命名规范化`
- `注释规范化`

## 工程化意义

```text
前端开发的管理工具，提升开发效率
```

### 一、模块化

> 《浅谈模块化开发》
>
> 《Javascript 模块化编程（一）：模块的写法》
>
> 《前端模块化：CommonJS，AMD，CMD，ES6》
>
> 《Module 的语法》

```text
分解与聚合
```

#### 模块化的发展流程

###### 1.初始以文件来区分模块

```
缺点：
	全局污染
	依赖混乱
```

###### 模块化的标准

|          标准           |                开发                | 官方标准 |                       执行方式                       |                使用                 |
| :---------------------: | :--------------------------------: | :------: | :--------------------------------------------------: | :---------------------------------: |
|     CommonJs /  CJS     |               nodejs               |    /     |           运行时--代码运行时，确定依赖关系           | 导入--require；导出--module.exports |
|           AMD           |                 /                  |    /     |                          /                           |                  /                  |
|           CMD           |                 /                  |    /     |                          /                           |                  /                  |
|           UMD           |                 /                  |    /     |                          /                           |                  /                  |
| SCMAScript Module / ESM | es6 / nodejs现在既支持CJS也支持ESM |    √     | 编译时--但是es7时的动态导入 @import('xx') 属于运行时 |     导入--import；打出--export      |

```
第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。
第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。
第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。
第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。
```



```
可以运行个模块化标准的环境：
	浏览器：ESM
	node：CJS/ESM
	构建工具：CJS/ESM
```

######  AMD 和 CMD 规范的区别

> 1. ```
>   第一个方面是在模块定义时对依赖的处理不同。AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。
>   ```
> ```
> 
> ```
>
> ```
> 
> ```
>
> 2. ```
>   第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，
>   ```
> ```
> 
> ```
>
> ```
> 
> ```

```js
// CMD
define(function(require, exports, module) {
  var a = require("./a");
  a.doSomething();
  // 此处略去 100 行
  var b = require("./b"); // 依赖可以就近书写
  b.doSomething();
  // ...
});

// AMD 默认推荐
define(["./a", "./b"], function(a, b) {
  // 依赖必须一开始就写好
  a.doSomething();
  // 此处略去 100 行
  b.doSomething();
  // ...
});

```

> 《前端模块化，AMD 与 CMD 的区别》

###### ES6 模块与 CommonJS 模块、AMD、CMD 的差异

```js
1.CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的
，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。

2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。
```

###### requireJS的核心原理

```
require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。```
```

> requireJS 的用法和原理分析》
>
> 《requireJS 的核心原理是什么？》
>
> 《requireJS 原理分析》

------

#### 包管理

```
package,一系列模块的集合。 函数--->模块--->包
```

```
从哪里下载包？
如何升级包？
如何卸载包？
如何发布包？
版本控制。
	这些都需要‘包管理’
```

```
node环境：
	npm pnpm yarn cnpm
浏览器环境：
	bower
```

npm存在幻影依赖的问题

#### 工程化需要解决的问题

##### 1. 语言问题

```
html、css、js很难适应复杂的工程化
```

###### a. html

```
现在大部分是单页面应用，整个页面的元素靠js的document.createElement 动态生成
```

###### b. css

```
1. 语法缺失：
	循环、判断、字符串拼接等逻辑性的语法是缺失的
2. 功能缺失：
	函数
	
	既然css语言缺失太多，那就重新写一套新的语言，在css语言基础上扩展大部分东西，如:scss、less、stylus	
```

<img src="C:\Users\Administrator\Desktop\Frontend Summary\E-工程化\屏幕截图 2024-02-28 135726.png" alt="屏幕截图 2024-02-28 135726" style="zoom: 50%;" />

```
	新语言是css的超集，css有的新语言有，css没有的新语言还有，但是，浏览器不识别新的语言，所以需要工具去编译，新语言通过’编译器‘转成css。
	这个编译器就是-->css预编译器（scss、less、stylus）
```

新语言经过css预编译器编译后的css代码，还有一些问题需要解决：

```
1. 厂商前缀的问题  -o、-webkit...
2. 代码压缩   空格、空行 去掉，提升运行效率
3. 代码剪枝  页面中原先用到的css，经过一些改变后用不到了，这些css不需要生成到最终的css代码中

这些问题需要工具去解决：
1. autoprefixer 解决厂商前缀
2. cssnano 可以代码压缩
3. purgecss 进行代码剪枝
4. css module 解决代码冲突
这些工具称为 css后处理器
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1709101099428.png" alt="1709101099428" style="zoom:50%;" />

```
预处理器将 新语言 转换 成 css
后处理器将 css	转换 成 css
postcss 就是 将这些转换逻辑抽离，而成的工具；与 babel类似，也需要插件支持。
	postcss
	postcss-cli
```

postcss配置

```javascript
// postcss.config.js
module.exports = {
    map: false, // 不生成surce-map  .map文件
    plugins: {
        tailwindcss:{}, // 原子css
        'postcss-preset-env':{}, // 预设
        'postcss-modules':{} // css module
    }
}
```

###### c. js

```
1.兼容性问题：
	a. API兼容：
		新的API在老版本浏览器（node）中不兼容，不能使用。
		这就需要在老版本中重写一个功能相同在老版本中运行的api这种做法叫做 polyfill
		polyfill：垫片/填充物；在老版本缺失这样的api重新填充一个。
		但是，手动填充会影响开发效率，需要一个工具帮我们完成这样的事情--->现在主流的是core-js,并不是所有的东西都可以polyfill。
	
	b. 语法兼容：
		API兼容可以填充API，而语法兼容需要对语法进行 ‘语法转换’。syntax transformer / runtime
		例如: async await 老版本不兼容es6，所以需要一个工具将 async await转换成老版本识别的语法，并且功能还在；regenerator将async await语法编译成另一段代码。
		到现在，解决语法兼容，一个工具解决一个或多个语法兼容问题，在开发中工具这么多，需要我们将这些工具整合起来。
		代码集成转换工具，用的最多的就是babel，babel将这些工具集成进来。
		
		@babel/core babel核心，提供转换代码的API （regenerator...）
		@babel/cli 命令行工具，可以在命令行输入命令，直接转换。
		
		babel会将代码转为AST语法树，结果与原代码没有太大区别，这是因为 还需要对应的插件
		
```

<img src="C:\Users\Administrator\Desktop\Frontend Summary\E-工程化\屏幕截图 2024-02-28 111559.png" alt="屏幕截图 2024-02-28 111559" style="zoom:50%;" />

```text
		例如：obj?.foo?.bar 转换还需要 @babel/plugin-transform-optioanal-chaining,并且配置babel.config.js.
        现在还是需要一个个下载插件，插件那么多也不可能所有的都记住，所有我们用到了 预设；
        预设：一堆插件，都已经配置好了，直接使用就可以。
        
        babel中有许多预设： 支持ts的预设/支持jsx的预设/基础预设@babel/preset-env
```

**babel.config.js**

```javascript
module.exports = {
    presets:[
        '@babel/preset-env'
        // 对预设需要进行一些配置 可以使用 []
        ['@babel/preset-env',{
            target:{ // 要兼容的浏览器信息  等同 browser list
                edge:'17',
                firefox:'60'
            },
            useBuiltIns: 'usage', //按需导入
            corejs:'3.32.2' // core-js 的版本
        }]
    ]
}
```

```
2. 语法增强
	语法兼容即可以处理兼容 也可以处理语法增强，都需要一个工具将代码进行转换-- babel
```

> 与babel功能相似的工具--swc(转换速度更快，使用rust编写)

##### 2. 工程问题

```
上边都是语言方面的处理，也就是代码层面的转换；
那么工程层面也需要进行转换，这就用到了： 构建工具、脚手架

开发和维护的代码 --> 需要转换 --> 运行时需要的代码
开发和维护的工程 --> 需要转换 --> 运行时需要的工程
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1709102263380.png" alt="1709102263380" style="zoom: 50%;" />

```
上面的工程（开发和维护的工程） 经过 构建工具 的转换，转换成下面‘运行时需要的工程’
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1709102818908.png" alt="1709102818908" style="zoom:50%;" />

###### 构建工具

```
构建工具需要做什么？
	那种工程更适合加法和维护？
	那种工程更适合运行时？
	如何转换（打包）
所以形成了多种构建工具： webpack、rollup、esbuild

webpack :一切皆为模块
```

![1710660763896](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1710660763896.png)

###### 开发服务器

```
	工程中代码经过 添加/修改后，想要看到效果，就需要转换为传统工程（html、css、js），这样太麻烦，所以就有了开发服务器。
	npm run serve 就会运行开发服务器
	开发服务器 用到 webpack-dev-server 核心是express
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1709105259315.png" alt="1709105259315" style="zoom:50%;" />

```
文件指纹  hash/contenthash  [hash:8]
```

###### 脚手架

```
界面交互
工程模板
```

##### 3. 流程问题

```
涉及架构
```

## 前端工程化做了些什么

## **1. 代码版本管理**

#### **代表性的工具：**

- **Git**：Git 是目前最流行的分布式版本控制系统，由 Linus Torvalds 开发。它提供了强大的分支管理、版本回溯、代码合并等功能，适用于个人开发者和大型团队。
- **Subversion（SVN）** ：Subversion 是一个集中式版本控制系统，适用于需要严格控制代码访问权限的环境。它提供了与 Git 类似的版本控制功能，但是采用了集中式的架构。

#### **解决的痛点：**

1. **版本控制**：在开发过程中，代码会不断地进行修改、添加和删除，版本控制系统（如 Git）能够记录每次变更的历史，包括修改内容、修改人员、修改时间等，为团队成员提供了一个可追溯的代码版本历史。
2. **代码备份与恢复**：通过版本控制系统，开发团队可以轻松地备份代码，并在需要时恢复到历史版本，避免因为误操作或者代码丢失导致的灾难性后果。
3. **并行开发与协作**：多人协作开发时，不同团队成员可能会同时修改同一个文件，版本控制系统能够自动合并这些修改，并提供冲突解决机制，保证团队成员的协作顺利进行。
4. **代码回滚与分支管理**：在项目开发过程中，可能会出现不同的开发分支，版本控制系统能够方便地进行分支管理，并提供代码回滚功能，使得在不同分支间切换和代码回退变得简单易行。
5. **代码审查与质量保障**：版本控制系统提供了代码审查和评审的功能，团队成员可以通过审查工具对代码进行评审和反馈，提高代码质量、发现潜在问题并及时进行修复。
6. **追踪问题与缺陷管理**：版本控制系统能够帮助团队追踪和管理项目中的问题和缺陷，包括 bug 报告、任务分配、问题解决进度等，提高了团队的工作效率和项目质量。

## **2. 模块化开发**

#### **模块化规范**

- **CommonJS**：CommonJS 是一种 JavaScript 模块化规范，最初被用于 Node.js 环境。它通过 `require` 和 `module.exports` 来实现模块之间的引用和导出。
- **AMD（Asynchronous Module Definition）** ：AMD 是另一种 JavaScript 模块化规范，主要用于浏览器环境中。它允许模块在加载和执行时异步进行，最常见的实现是 RequireJS。
- **ES6 模块**：ES6 引入了官方的模块化方案，使用 `import` 和 `export` 关键字来实现模块的导入和导出。ES6 模块可以在浏览器和 Node.js 环境中使用。

#### **模块化打包工具**

- **Webpack**：Webpack 是一个现代的 JavaScript 应用程序静态模块打包器。它可以将多个模块打包成一个或多个输出文件，并且支持代码分割、懒加载、模块热替换等功能。
- **Rollup**：Rollup 是一个 JavaScript 模块打包器，专注于将 ES6 模块打包成优化的输出文件。它具有更高的性能和更小的输出体积，适合用于库和框架的打包。
- **Vite**：Vite 是一个基于原生 ES 模块的快速开发工具。它利用浏览器原生支持 ES 模块的特性，不需要预先构建，因此具有快速的冷启动速度。Vite 适用于 Vue.js、React 和 Svelte 等框架的开发。
- **Snowpack**：Snowpack 是另一个基于 ES 模块的现代构建工具，与 Vite 类似，它也支持快速的开发体验。Snowpack 支持多种框架，包括 React、Vue.js、Angular、Svelte 等。

#### **采用组件化开发思想的库**

- **Vue**：Vue.js 是一种流行的前端 JavaScript 框架，它采用了组件化开发的思想。Vue.js 组件可以被看作是一种模块，可以被灵活地组合和复用，使得应用程序的开发更加模块化和可维护。
- **React**：React 是另一种流行的前端 JavaScript 框架，也采用了组件化开发的思想。React 组件可以通过 JSX 语法定义，并通过导入和导出来实现模块化的开发。
- **Angular**：Angular 是一个由 Google 开发的流行的前端框架，它提供了一整套工具和库，用于构建大型、高性能的 Web 应用程序。Angular 使用了组件化的开发方式，开发者可以通过 Angular 组件来构建复杂的用户界面。
- **Svelte**：Svelte 是一个新兴的前端框架，它采用了一种不同于 Vue.js 和 React 的编译时框架的方式。Svelte 在构建时将组件转换为高效的纯 JavaScript 代码，不需要运行时框架，因此具有非常小的体积和高性能。
- **web components**：Web Components 是一种用于构建可重用组件的技术，它由一组不同的浏览器特性组成，包括自定义元素、影子 DOM、HTML 模板和 HTML 导入。通过使用 Web Components，开发者可以创建具有封装性、可重用性和可组合性的定制化 HTML 元素，这些元素可以在任何支持 Web Components 的环境中使用，无需额外的框架或库。

#### **解决的痛点**

1. **代码组织混乱**：在传统的开发方式中，所有的代码通常都放在一个文件或者少数几个文件中，导致代码组织混乱，难以维护和理解。模块化开发将代码拆分成多个模块或组件，每个模块或组件都专注于一个特定的功能或责任，使得代码组织更加清晰明了。
2. **代码复用困难**：在传统的开发方式中，代码复用通常通过复制粘贴来实现，容易产生重复的代码和耦合性高的问题。模块化开发提倡代码的复用和组合，开发者可以将通用的功能封装成模块或组件，然后在不同的地方引用和复用，从而减少重复劳动，提高代码的可维护性和复用性。
3. **协作开发困难**：在传统的开发方式中，多人协作开发时往往存在代码冲突和覆盖的问题，导致团队协作效率低下。模块化开发将代码拆分成多个独立的模块或组件，每个模块或组件都有自己的接口和功能，可以独立开发和测试，降低了团队成员之间的依赖和冲突。
4. **代码维护困难**：在传统的开发方式中，随着项目规模的增大，代码的维护成本也会随之增加，因为代码之间的依赖关系复杂，难以理清和维护。模块化开发将代码拆分成多个模块或组件，每个模块或组件都是独立的，易于理解和维护，降低了代码的维护成本。
5. **性能优化困难**：在传统的开发方式中，往往存在大量的冗余代码和无效代码，影响了应用程序的性能。模块化开发将代码拆分成多个模块或组件，每个模块或组件都是精简的，可以针对性地进行性能优化，提高了应用程序的性能和响应速度。

## **3. 质量与规范**

#### **规范化工具**

- **ESLint**：ESLint 是 JavaScript 的静态代码分析工具，可以帮助开发团队发现和修复代码中的问题，并确保代码符合制定的编码规范。ESLint 提供了丰富的配置选项和插件生态系统，可以满足不同项目的需求。
- **Prettier**：Prettier 是一个代码格式化工具，可以帮助开发者自动格式化代码，使其符合统一的风格和规范。Prettier 支持多种编程语言，并提供了可定制的配置选项。
- **Stylelint**：Stylelint 是用于检查 CSS、SCSS、Less 等样式文件的代码质量和规范的工具。它类似于 ESLint，可以帮助开发者发现和修复样式文件中的问题，并确保样式代码符合指定的规范。
- **Husky 和 lint-staged**：Husky 和 lint-staged 是两个常用的工具，用于在代码提交前进行代码质量和规范检查。Husky 可以在 Git 钩子事件触发时执行预定义的脚本，而 lint-staged 可以在提交的文件上运行指定的 linter。
- **CommitLint**：CommitLint 是一个用于检查提交消息是否符合规范的工具。它可以帮助开发者编写清晰、一致的提交消息，并规范提交日志的格式。
- **Codecov 和 Coveralls**：Codecov 和 Coveralls 是两个常用的代码覆盖率检查工具，用于帮助开发团队检查测试覆盖率，并发现测试用例中的盲点和遗漏。

#### **质量保证**

- **TypeScript**：在一定程度上也可以算作代码质量与规范工具的一部分，尽管它更多地被视为一种编程语言。它解决了以下问题

- 1. **类型检查**：TypeScript提供了静态类型检查功能，可以在编译时发现代码中的类型错误，避免在运行时出现意外的类型错误，提高代码的稳定性和可靠性。
  2. **代码提示和自动补全**：TypeScript 能够根据变量和函数的类型信息提供更准确的代码提示和自动补全，减少开发过程中的错误和拼写错误，提高开发效率。
  3. **接口和类型定义**：TypeScript 支持接口和类型别名的定义，可以帮助开发者明确地定义数据结构和接口，提高代码的可读性和可维护性。
  4. **代码重构**：TypeScript 提供了强大的重构功能，包括重命名、提取函数、提取类型等，可以帮助开发者快速地对代码进行重构，改善代码结构和质量。

- **Jest**：Jest 是一个基于 JavaScript 的测试框架，由 Facebook 开发，广泛应用于前端和后端的单元测试、集成测试和端到端测试等场景。Jest 支持异步测试、快照测试、覆盖率报告等功能，并提供了易于使用的 API 和丰富的插件生态系统。

- **Mocha**：Mocha 是另一个流行的 JavaScript 测试框架，它支持多种测试风格（如 BDD、TDD 等），可以用于编写各种类型的测试，包括单元测试、集成测试、功能测试等。

- **Sentry**：Sentry 是一款开源的实时错误监控和报告工具，旨在帮助开发团队发现、诊断和解决应用程序中的错误和异常。Sentry 提供了丰富的功能，包括实时错误报告、错误分析、错误趋势分析、性能监控、用户反馈收集等，可用于监控 Web、移动和后端应用程序

- **Lighthouse**：Lighthouse 是一个由 Google Chrome 提供的开源工具，用于评估网站的性能、可访问性、最佳实践等方面。它可以在 Chrome 浏览器中作为插件运行，也可以通过命令行工具进行批量测试

- **Webpack Bundle Analyzer**：Webpack Bundle Analyzer 是一个 Webpack 插件，可以帮助开发者分析和优化 Webpack 打包生成的资源文件，识别并优化打包过程中的性能瓶颈。

#### **解决的痛点**

1. **一致性问题**：在团队开发中，不同开发者可能有不同的编码风格和习惯，导致代码风格不一致。代码质量与规范工具可以通过预定义的规则和规范，强制统一团队的代码风格，确保代码风格的一致性。
2. **代码质量问题**：开发过程中难免会出现一些代码质量问题，如潜在的 bug、代码可读性差、性能问题等。代码质量与规范工具可以帮助开发者及时发现和修复这些问题，提高代码的质量和可维护性。
3. **项目性能问题**：针对应用程序加载速度慢、性能不佳，性能评估工具可以帮助指引我们优化的方向，提高用户体验。

## **4. 自动化**

#### **先聊聊什么是CI/CD**

> CI/CD 是持续集成（Continuous Integration）和持续部署/交付（Continuous Deployment/Delivery）的缩写，是一种软件开发实践，旨在通过自动化流程来频繁地构建、测试和部署应用程序，以提高开发团队的效率和产品质量。

- **持续集成（Continuous Integration，CI）** ：持续集成是指将团队成员对代码的修改频繁地集成到共享代码库中，并自动进行构建、测试和验证的过程。开发者提交代码到版本控制系统后，CI 系统会自动触发构建流程，编译代码、运行测试，并提供构建结果和测试报告。CI 的目标是尽早地发现和解决代码集成问题，确保团队开发的代码始终处于可用状态，并减少代码集成带来的风险。
- **持续部署/交付（Continuous Deployment/Delivery，CD）** ：持续部署/交付是指将经过测试的代码自动部署到生产环境（持续部署）或者发布到预备环境等待手动部署（持续交付）的过程。在持续部署模式下，通过自动化流程将代码从开发环境直接部署到生产环境，无需人工干预。在持续交付模式下，将经过测试的代码发布到预备环境，等待手动触发部署操作

#### **代表性的工具**

- **自动化构建工具**：上文提到的`vite` 、`webpack` 、`rollup` 、`snowpack`等皆是自动化构建工具，为我们提供了编译与打包、自动化测试、开发服务器、代码检查等功能，这里不再赘述。
- **GitLab CI**：GitLab CI 是 GitLab 的一部分，提供了内置的持续集成和持续部署功能。它与 GitLab 代码仓库紧密集成，支持在 GitLab 上配置和管理 CI/CD 流水线。
- **Jenkins**：Jenkins 是一款开源的持续集成/持续部署工具，具有丰富的插件生态系统和灵活的配置选项。它支持构建、测试和部署各种类型的项目，并可以与多种版本控制系统和工具集成。
- **GitHub Actions**：GitHub Actions 是 GitHub 提供的一项功能，用于实现持续集成和持续部署。它与 GitHub 代码仓库紧密集成，允许开发者在仓库中配置自定义的 CI/CD 流程，包括构建、测试、部署等操作。GitHub Actions 支持使用 YAML 文件定义工作流程，可以使用 GitHub 提供的预定义动作或者自定义动作来实现各种功能。由于与 GitHub 平台紧密集成，GitHub Actions 具有良好的可用性和便捷性，特别适用于 GitHub 上的开源项目。

#### **解决的痛点**

1. **提高开发效率**：自动化构建工具和CI/CD可以自动化执行繁琐的构建、测试和部署任务，减少了手动操作的时间和精力，提高了开发团队的工作效率。
2. **减少人为错误**：人为操作往往容易出错，而自动化流程可以大大减少人为错误的发生。自动化构建工具可以确保每次构建过程都是一致的，CI/CD 流程可以提前发现代码集成问题，减少了错误的传播和影响范围。
3. **加速交付周期**：自动化构建工具和 CI/CD 可以加速软件交付周期，通过自动化流程实现快速的构建、测试和部署，使新功能和变更更快地交付给用户，缩短了产品迭代周期。

## **5. 接口管理和数据模拟**

#### **代表性的工具**

- **Postman**：Postman 是一款流行的 API开发和测试工具，它提供了丰富的功能，包括接口管理、测试、调试和文档生成等。Postman 支持创建和管理 API 请求，并提供了强大的断言和测试功能，可以模拟请求和响应，进行自动化测试。
- **Swagger（OpenAPI）** ：Swagger 是一种 API 规范和文档工具，它允许开发者定义和描述 API 的结构、参数、路径和响应等信息，并生成对应的 API 文档。Swagger 还提供了交互式的 API 测试界面，可以直接在文档中测试 API，并生成客户端代码。
- **MockServer**：MockServer 是一款开源的 API 模拟工具，可以用于模拟 HTTP 和 HTTPS 请求，并返回预先定义的响应。MockServer 支持复杂的请求匹配规则、响应动态生成和模拟场景配置，可以用于开发、测试和调试阶段。
- **mockjs**：Mock.js 是一个用于生成随机数据和模拟 HTTP 请求响应的 JavaScript 库，可以帮助开发者快速搭建一个虚拟的后端环境，以便于前端开发和测试。

#### **解决的痛点**

1. **加速开发周期**：这些工具允许前端和后端团队并行开发，而不需要等待完整的后端 API 实现。前端团队可以使用 Postman、Swagger 和 Mock.js 等工具来模拟后端 API 的行为，从而加速开发周期。
2. **降低沟通成本**：使用这些工具可以帮助前端和后端团队更好地协作。通过提供明确的 API 接口文档（如 Swagger），前端和后端团队可以更容易地理解彼此的需求，减少沟通成本和误解。
3. **减少依赖和提高灵活性**：前端团队不再需要依赖于后端团队提供的真实 API，而是可以使用模拟数据（如 Mock.js）或者测试环境（如 Postman）来进行开发和测试。这提高了开发的灵活性，并降低了对后端的依赖

## 前端工程化

#### 评审

1. UI 标准规范，组件库
2. 物料库

#### 准备开发

1. 仓库的创建，devops 平台（例如域名地址生成，网关路径匹配）
2. 项目初始化，也就是脚手架初始化项目
3. 包管理 monorepo ，文件管理、目录管理等规范
4. js、css 等规范

#### 开发阶段

1. git 分支管理，code review 等
2. IDE
3. 编译相关，也就是基于 webpack、vite 等 eslint 等大家熟知的工具链相关
4. 私有化 npm 仓库
5. 本地 mock 服务
6. 打包配置
7. 单元测试

#### 发布交付

1. git hook 提交等流水相关
2. 打包构建，CDN 相关
3. jenkins、 docker、k8s 等镜像管理
4. 自动化测试
5. A、B test

#### 上线

1. 前端监控
2. 埋点