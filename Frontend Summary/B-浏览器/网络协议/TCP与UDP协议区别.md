# 【网络协议】TCP与UDP协议区别及应用场景深度分析！！！

![1719140293084](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1719140293084.png)

**1. TCP与UDP简介**

**1.1 TCP定义**

​        TCP（TransmissionControl Protocol）传输控制协议。

​       是一种可靠的、面向连接的协议（eg:打电话）、传输效率低全双工通信（发送缓存&接收缓存）、面向字节流。使用TCP的应用：Web浏览器；电子邮件、文件传输程序。

**1.2 TCP特性**

**1.2.1．是面向连接的协议**

​      也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来。接收双方独占一个通道。

**1.2.2．面向字节流**

​      TCP将应用程序看成是一连串的无结构的字节流。每个TCP套接口有一个发送缓冲区，如果字节流太长时，TCP会将其拆分进行发送。当字节流太短时，TCP会等待缓冲区中的字节流达到一定程度时再构成报文发送出去，TCP发给对方的数据，对方在收到数据时必须给予确认，只有在收到对方的确认时，本方TCP才会把TCP发送缓冲区中的数据删除。

#### 1.2.3．3次握手建立连接，4次握手释放连接

![1719140323033](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1719140323033.png)

**ACK：**TCP报头的控制位之一，表示确认号是否有效。只有当ACK=1时，确认号才有效，当ACK=0时，确认号无效，这时会要求重传数据，保证数据的完整性。

**确认号：**用它来告诉发送端发送过来的序列号之前的数据段都收到了。比如，确认号为X，则表示前X-1个数据段都收到了。

**SYN：**同步序列号，TCP建立连接时将这个位置1。

**FIN：**发送端完成发送任务位，当TCP完成数据传输需要断开时，提出断开连接的一方将这位置1。

**1.2.4 TCP建立连接三次握手过程**

1、主机A通过向主机B发送一个含有同步序列号的标志位的数据段给主机B ，向主机B 请求建立连接，通过这个数据段，主机A告诉主机B 两件事：我想要和你通信；你可以用哪个序列号作为起始数据段来回应我。

2、主机B 收到主机A的请求后，用一个带有确认应答(ACK)和同步序列号(SYN)标志位的数据段响应主机A，也告诉主机A两件事：我已经收到你的请求了，你可以传输数据了；你要用哪个序列号作为起始数据段来回应我。

3、主机A收到这个数据段后，再发送一个确认应答，确认已收到主机B 的数据段：我已收到回复，我现在要开始传输实际数据了。

![1719140344127](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1719140344127.png)

**1.2.5 OSI和TCP参考模型对比**

![1719140358609](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1719140358609.png)



**2、UDP**

**2.1 UDP定义**

UDP（User DatagramProtocol）用户数据报协议

​    不可靠的、无连接的服务，传输效率高（发送前时延小），一对一、一对多、多对一、多对多、面向报文，尽最大努力服务，无拥塞控制。使用UDP的应用：域名系统 (DNS)；视频流；IP语音(VoIP)。

**2.2 UDP特性**

**2.2.1．无连接的服务**

​    UDP是一个非连接的协议，传输数据之前源端和终端不建立连接，双方没有专有的通信通道。当发送端想传送数据时就简单地把数据扔到网络上，并不能保证他们能到达目的地。接收端由于没有与发送端建立专用的通信通道，因此接收数据时并不能确定是有谁发来的数据。



**2.2.2．面向报文**

​       发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界。也就是说应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。

​    不同于TCP有缓存机制。TCP是将发送的数据都看成字节流，根据字节流在缓冲区存储的大小来决定是否发送，一次发送的信息不一定是整个报文。

​    使用UDP发送信息，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。

![1719140804403](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1719140804403.png)



**3. TCP与UDP的对比**

**3.1 基本区别**

1、TCP面向连接（如打电话要先拨号建立连接）。UDP是无连接的，即发送数据之前不需要建立连接。

2、对系统资源的要求（TCP较多，UDP少）。TCP需要建立专用的通信通道，还需要校验数据等，因此需求的系统资源较大。

3、TCP保证数据正确性，TCP丢包会自动重传，UDP可能丢包，丢包后不会自动重传。TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。

4、TCP保证数据传输有序，UDP不保证。

​    消息在传输过程中可能会乱序，后发送的消息可能会先到达，TCP会对其进行重排序，UDP不会。

4、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流。UDP是面向报文的

5、UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）

6、每一条TCP连接只能是点到点的。UDP支持一对一，一对多，多对一和多对多的交互通信。

7、TCP首部开销20字节。UDP的首部开销小，只有8个字节

![1719140822619](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1719140822619.png)

**3.2 编程上的区别**

![1719140872020](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1719140872020.png)

从程序实现的角度来看，可以用下图来进行描述。

![1719140928700](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1719140928700.png)

**TCP编程的服务器端一般步骤是：**

　　1、创建一个socket，用函数socket()。

　　2、设置socket属性。

　　3、绑定本机的IP地址、端口等信息到socket上，用函数bind()。

　　4、开启监听，用函数listen()。

​     5、接收客户端上来的连接，用函数accept()。

​     6、通过accept()返回相应客户端的socket建立专用的通信通道。

　　7、收发数据，用函数send()和recv()，或者read()和write()。

　　8、关闭网络连接。

　　9、关闭监听。

**TCP编程的客户端一般步骤是：**

　　1、创建一个socket，用函数socket()。

　　2、设置socket属性。　

　　3、设置要连接的对方的IP地址和端口等属性。

　　4、连接服务器，用函数connect()。

　　5、收发数据，用函数send()和recv()，或者read()和write()。

　　6、关闭网络连接。　

　

**UDP编程的服务器端一般步骤是：**

　　1、创建一个socket，用函数socket()。

　　2、设置socket属性。

　　3、绑定IP地址、端口等信息到socket上，用函数bind()。

　　4、循环接收数据，用函数recvfrom()。

　　5、关闭网络连接。

**UDP编程的客户端一般步骤是：**

　　1、创建一个socket，用函数socket()。

　　2、设置socket属性。　　

　　4、设置对方的IP地址和端口等属性。

　　5、发送数据，用函数sendto()。

　　6、关闭网络连接。 

**3.3 TCP/UDP应用场景**

**什么时候应该使用TCP：**

​    当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 

在日常生活中，常见使用TCP协议的应用如下：

​    浏览器，用的HTTP

​    FlashFXP，用的FTP

​    Outlook，用的POP、SMTP

​    Putty，用的Telnet、SSH

​    QQ文件传输

​    …………

**那么什么时候应该使用UDP：**

​    当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 

​    比如，日常生活中，常见使用UDP协议的应用如下：

​    QQ语音

​    QQ视频

​    TFTP

​    DNS的传输层协议有TCP或者UDP，常用的应该是UDP。



**3.4 DNS解析过程**

1、在浏览器中输入www.qq.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。

2、如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。

3、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。

4、如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。

5、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到www.qq.com主机。

6、如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。

![1719141029936](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1719141029936.png)

**1. 为什么建立TCP连接是三次握手，而关闭连接却是四次挥手呢？**

​    这是因为服务端的 LISTEN 状态下的 SOCKET 当收到 SYN 报文的建连请求后，它可以把 ACK和 SYN（ACK 起应答作用， 而 SYN 起同步作用） 放在一个报文里来发送。但关闭连接时， 当收到对方的 FIN 报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭 SOCKET, 也即你可能还需要发送一些数据给对方之后，再发送 FIN 报文给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文和 FIN报文多数情况下都是分开发送的。



**2. 为什么 TIME_WAIT 状态还需要等 2MSL 后才能返回到 CLOSED 状态？**

​    这是因为虽然双方都同意关闭连接了， 而且握手的 4 个报文也都协调和发送完毕， 按理可以直接回到 CLOSED 状态（就好比从 SYN_SEND 状态到 ESTABLISH 状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的 ACK 报文会一定被对方收到，因此对方处于LAST_ACK 状态下的 SOCKET 可能会因为超时未收到 ACK 报文，而重发 FIN 报文，所以这个TIME_WAIT 状态的作用就是用来重发可能丢失的 ACK 报文。

![1719141066700](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1719141066700.png)



 **3. TCP\UDP协议的设计区别是什么？列举所知道的使用TCP\UDP的上层协议。**

   **3.1 连接方面区别**

​    TCP面向连接，传输数据之前需要建立连接

​    UDP是无连接的，即发送数据之前不需要建立连接。

   **3.2 安全方面的区别**

​    TCP提供可靠的服务，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达。

​    UDP尽最大努力交付，即不保证可靠交付。

   **3.3 传输效率的区别**

​    TCP传输效率相对较低。

​    UDP传输效率高，适用于对高速传输和实时性有较高的通信或广播通信。

   **3.4 连接对象数量的区别**

​        TCP连接只能是点到点、一对一的。

​        UDP支持一对一，一对多，多对一和多对多的交互通信。

​        基于TCP的应用层协议有：HTTP、FTP、SMTP、TELNET、SSH

​      基于UDP的应用层协议：DNS、TFTP（简单文件传输协议）、SNMP(简单网络管理协议)、NTP协议

![1719141093786](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1719141093786.png)

**4. 为什么tcp是可靠的传输，简述你理解的原因。**

**4.1** **确认和重传机制**

建立连接时三次握手同步双方的“序列号 + 确认号 + 窗口大小信息”，是确认重传、流控的基础。传输过程中，如果Checksum校验失败、丢包或延时，发送端重传

**4.2** **数据排序**

TCP有专门的序列号SN字段，可提供数据re-order

**4.3** **流量控制**

窗口和计时器的使用。TCP窗口中会指明双方能够发送接收的最大数据量

**4.4** **拥塞控制**

**TCP的拥塞控制由4个核心算法组成:**

**“慢启动”（Slow Start）：**在开始发送数据时，先发送少量的数据探路。探清当前的网络状态如何，再决定多大的速度进行传输。

**“拥塞避免”（Congestion avoidance）：**从慢启动可以看到，cwnd可以很快的增长上来，从而最大程度利用网络带宽资源，但是cwnd不能一直这样无限增长下去，一定需要某个限制。TCP使用了一个叫慢启动门限(ssthresh)的变量，当cwnd超过该值后，慢启动过程结束，进入拥塞避免阶段。

**“快速重传 ”（Fast Retransmit）：**快重传算法要求首先接收方收到一个失序的报文段后就立刻发出重复确认，而不要等待自己发送数据时才进行捎带确认。

**“快速恢复”（Fast Recovery）：**

1.当收到3个重复ACK时，把ssthresh设置为cwnd的一半，把cwnd设置为ssthresh的值加3，然后重传丢失的报文段，加3的原因是因为收到3个重复的ACK，表明有3个“老”的数据包离开了网络。

2.再收到重复的ACK时，拥塞窗口增加1。

3.当收到新的数据包的ACK时，把cwnd设置为第一步中的ssthresh的值。原因是因为该ACK确认了新的数据，说明从重复ACK时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态。从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。